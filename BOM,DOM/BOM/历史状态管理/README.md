# 历史状态管理

## history 对象

### 方法

通过`history.pushState()`方法，可以将新的状态信息加入历史状态栈，而浏览器地址栏也会变成新的相对`URL`。需要三个参数：状态对象、新状态的标题、可选的相对 `URL`。
可以在不加载新页面的情况下改变浏览器的 `URL`。

> 第一个参数的对象可以是任何能够通过`JSON.stringify()`方法转换成相应字符串形式的对象。
> 第二个参数是一个可选的标题（普通的文本字符串）
> 第三个参数是一个可选的 `URL`，表示当前状态的位置

此时浏览器的后退按钮也可使用，按下后会触发`window`对象的`popstate`事件，该事件有一个`state`属性，包含着当初以第一个参数传递给`pushState()`的状态对象的副本。（深度复制）

> `popstate`事件仅会在对浏览器的做出动作时触发，比如点击浏览器前进/后退按钮，或调用`history.go()/back()/forward()`方法；调用`history.pushState()/或history.replaceState()`不会触发

要更新当前状态，可以调用`replaceState()`方法，传入的参数与`pushState()`的前两个参数相同。调用该方法不会在历史状态栈中创建新状态，只会重写当前状态。

`History`对象的`back()`与`forward()`方法与浏览器的后退和前进按钮一样。`go()`方法接受一个整数参数，表示向前(正参数)或向后(负参数)跳过任意多个页面。
如果窗口包含多个子窗口（`iframe`），子窗口的浏览历史会按时间顺序穿插在主窗口的历史中。

`History`对象可以通过自身的`state`属性来获得当前状态。

## 浏览器定位和导航(Location 对象)

`window`的`location`属性引用的是`Location`对象，它表示该窗口中当前显示的文档的 URL，并定义了方法来使窗口载入新的文档。

`Document`对象的`location`属性也引用到`Location`对象，`Document`对象也有一个 URL 属性，是文档首次载入后保存该文档的 URL 的**静态**字符串。 \*如果定位到文档的片段标识符（如`#table`），`Location`对象会做相应的更改，而`document.URL`**不变\***。

### 解析 URL

`Location`对象的`href`属性是一个字符串，包含 URL 的完整文本。它的`toString()`方法返回`href`属性的值。

### 载入新的文档

`Location`对象的`assign()`方法可以使窗口载入并显示你指定的 URL 中的文档。`replace()`方法类似，但*它在载入新文档之前会从浏览器历史中把当前文档删除*。两者的区别是前者在跳转后可以使用浏览器后退按钮后退，而后者不能。

可以用`reload()`方法，重新加载当前文档。使浏览器跳转到新页面也可以直接给`location`属性赋值 URL 地址，但**纯粹的片段标识符会使浏览器跳转到指定位置**，但如果文档中没有元素的 ID 是片段标识符那么跳转到文档开始处。

```js
location = '#top' //跳转到id为top的元素
```

### 监听 hash 值变化

比较简单的历史记录管理就是利用`location.hash`和`hashchange`事件。设置`location.hash`属性会更新显示在地址栏的 URL，并在浏览器历史记录添加一条记录。

## hash 路由和 history 路由的区别

在使用体验上，两者对于用户的感知性不强，体验基本上一致。唯一区别是，`hash`模式路径通过`#`后跟路径出现；`history`模式路径直接通过`URL`路径的形式出现。

从开发的角度来说：

-   对于每一个路径的处理，`hash`模式不要首次文档的载入；而`history`模式后端需要关注首次文档的载入。

-   `hash`模式下，对于`URL`的改变不会向后端发起请求；`history`模式下，对于`URL`的改变会向后端发起请求。
