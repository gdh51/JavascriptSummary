# 标识符相关规则

## 标识符命名

Javascript 中表达式必须以*字母*、*下划线*或*美元符号*开始，后续字符可以是字母、数字、下划线或美元符号。
Javascript 标识符中还可以包含 *Unicode* 字符集中的字母和数字。

当出现标识符时，Javascript 会将其当作变量而去查找它的值。变量名不存在则会抛出错误`ReferenceError`。(具体原理你可以在[引擎执行过程](../引擎执行过程/README.md)中找到)

## 变量

变量和标识符直接存在关联关系，这样我们可以通过访问标识符来找到对应变量。一般来说，我们称标识符为变量。

### 变量声明

用`var/let`声明了变量但未赋值，则它的初始值为`undefined`；通过`const`声明时其必须在声明时赋值，否则其值一直为`undefined`。

抽象的说，变量声明分为 **创建**、**初始化**、**赋值** 三个阶段

#### 作为属性的变量

当声明一个 Javascript 全局变量时，实际上是定义了全局对象的一个属性——当使用`var`声明一个全局变量时，创建时这个属性是不可配置的，这个变量无法通过`delete`运算符删除；当给一个**未声明**的变量赋值时， Javascript 会创建一个全局变量。以这种方式创建的变量是全局对象的正常的可配值属性（可删除）

### 变量作用域

当访问一个变量时，局部变量的优先级高于全局变量。

局部变量可以当作跟函数相关的某个对象的属性，成为声明上下文对象。

Javascript 是基于词法环境：**通过阅读包含变量定义在内的数行源码就能知道变量的作用域**

### 函数作用域和声明提前

类 C 语言中，花括号内的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的，这种称之为块级作用域。Javascript 可以通过下面的代码定义一个块级作用域：

```js
// 这是一个块作用域
{
    let a = 1
}
```

Javascript 拥有函数作用域：_变量在声明它们的函数以及这个函数体嵌套的任意函数体内都是有定义的。_

**变量提升**：在创建执行上下文时，会将其中的变量声明的变量(通过`var`声明的变量)立即进行创建和初始化到当前作用域顶部（即声明之前就已有该变量）。函数声明会执行创建、初始化与赋值三个过程。如下例：

```js
var scope = 'global';
function f() {
    console.log(scope); //输出undefined
    var scope = 'local'; //变量在这里赋初始值，但变量在函数体内任何地方都有定义
    console.log(scope); //local
}
f();
```

在调用`f()`函数时，首先它会为`f()`，函数创建执行上下文，这个过程中会在确认`this`的指向和当前执行上下文的词法环境和变量环境，此时就会在变量环境上创建并初始化一个`scope`变量，其赋值为`undefined`。待代码执行阶段，在执行`var scope = 'local'`时，当我们在访问上述代码第一个`scope`时，会得到`undefined`，而在执行`var scope = 'local'`后会得到对应的局部变量值`local`。

> 该条规则指针对通过`var`声明的变量, 通过不同的方式声明的对象，会按不同的情况在声明时选择性地执行**创建、初始化、赋值**三个阶段。
> 例如通过 `let/const` 声明变量时, 在创建执行上下文时只会执行变量的创建阶段。

上述情况存在一个特殊的情况，看下面这个场景：

```js
var a = 1
try {
    console.log(x)
} catch (e) {
    console.log(a) // 1 not undefined
    var a = 2
}
```

在上述情况中，访问`try`语句块中的`x`会报错导致执行`catch`子语句。在执行`catch`子语句时，其会创建一个执行上下文，其具有新的词法环境但仍使用的是`catch`语句外部的变量环境，这就导致了当我们访问`a`时，其会直接返回已经定义过的`a`，而不是和前一个例子一样的情况。
