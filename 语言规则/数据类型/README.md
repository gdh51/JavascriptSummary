# 数据类型
Javascript的数据类型分为两类：**原始类型**和**引用类型**

原始类型(基本类型)分为：`Number`、`String`、`Boolean`、`null`、`undefined` 、(ES6新增)`Symbol` ，它们都是不可变类型
引用类型为：`Object`

## Number
由于Javascript采用IEE-754浮点数表示法，是一种二进制表示法，占用64bit，不能精准的表示类似0.1之类的简单数字，所以你会看到如下情况：
```js
var x = 0.3 - 0.2;//0.099999999999998
var y = 0.2 - 0.1;//0.1
console.log(x == y);//false

1.335.toFixed(2); // 1.33

var x = 9007199254740992
x + 1 == x // true
```

在这64bit中其中 第1位用来表示符号位 2~11位表示指数(共11位,偏移值为1023) 12~64位表示尾数(即有效域,共52位)

>*指数*永远为一个非负数,减去偏移值后才为正真的指数,所以指数域的取值为 0 <= e <= 2<sup>11</sup>,真正的指数就为 -1023 <= E <= 1024

*尾数*表示有效域部分，**只能存储52位的数字，多余的自动去除**。在二进制科学计数法中，要保证小数点前必须有一位非0数,那么有效域必然为1.XXXX,这种样子的二进制被称为*规格化的*，这种二进制存储时，1.默认不占尾数位置,尾数部分从第一个X开始;当一个二进制小数无限接近于0时，如要保持1.XXXX的形式，那么指数部分必然取-1023,但如果取该指数值都没能达到1.XXXX的形式，那么只能用0.XXXX来表示有效部分,这样的二进制被称为*非规格化的*


>一个数用公式来表示就为 x = (-1)<sup>符号位</sup> x (1.尾数) x 2<sup>(指数域 - 偏移量)</sup>

所有的数值都按照此公式计算

0.1的二进制为0.0 0011 0011 0011..(循环0011)
0.2的二进制为0.0011 0011 0011..(0011无限循环)
此处精度丢失的原因在于相加后舍去了双方后面的循环,它们超过了52位尾数

大整数的精度丢失和浮点数本质上是一样的，尾数位最大是52位，因此Javascript中能精准表示的最大整数是` Math.pow(2, 53)`，十进制即 9007199254740992。(上述第二种情况) 超出这个范围就不能保证精度问题了

解决方法：
1. 不超出精度范围(64)
2. 自行转换，如下：
```js
function numAdd(num1/*:String*/, num2/*:String*/) {
    var baseNum, baseNum1, baseNum2;
    try {
        //取得第一个操作数小数点后有几位数字，注意这里的num1是字符串形式的
        baseNum1 = num1.split(".")[1].length;
    } catch (e) {
        //没有小数点就设为0
        baseNum1 = 0;
    }
    try {
        //取得第二个操作数小数点后有几位数字
        baseNum2 = num2.split(".")[1].length;
    } catch (e) {
        baseNum2 = 0;
    }
    //计算需要 乘上多少数量级 才能把小数转化为整数
    baseNum = Math.pow(10, Math.max(baseNum1, baseNum2));
    //把两个操作数先乘上计算所得数量级转化为整数再计算，结果再除以这个数量级转回小数
    return (num1 * baseNum + num2 * baseNum).toFixed(0) / baseNum;
};
```

[部分参考](https://segmentfault.com/a/1190000009084877#articleHeader1)

## String
Javascript中文本由一组16位值组成的不可变的有序序列，每个字符通常来自于Unicode字符集。

>字符串的长度是其所含16位值的个数。

最常用的Unicode字符都是通过16位内码表示，并代表字符串中的单个字符，那些不能表示为16位的Unicode字符遵循UTF-16编码规则——用两个16位值组成的一个序列（*代理项对*）表示。这意味着一个长度为2的Javascript字符串有可能表示一个Unicode字符：
```js
var p = "π";//长度为1   16位内码为0x03c0
var e = "𝑒";//长度为2   17位内码为0x1d452
//e通过UTF-16编码后包含两个16位值:"\ud835\udc52"
```

Javascript定义的各种字符串操作方法均作用于16位值而非字符（ES6之前），且不会对*代理项对*做单独处理，同样Javascript不会对字符串做标准化的加工，甚至不能保证字符串是合法的UTF-16格式

### 字符串直接量
字符串可以拆分为数行，且每行必须以` \ `结束，（` \ `与` \n `都不算字符串的直接量内容）当想字符串直接量另起一行时可以使用转义字符（` \n `）
```js
var strings="two\
lines"  //这是一个单行代码表示  twolines
```

### 转义字符
` \ `后加一个字符，就不再表示它们的字面含义了。

### 字符串的加法
当用` + `运算符作用于字符串时，表示将第二个字符串拼接在第一个之后

要确认一个字符串的长度——其所包含的16位值的个数——可以用字符串的`length`属性

**Javascript中字符串是固定不变的，某些方法都是返回新的字符串，原字符串本身并没有发生改变**。

字符串可以作为只读数组，除了使用`charAt()`，还可以直接通过方括号来访问字符串中的单个字符（16位值）：
```js
strings2 = 'twossss';
strings2[0];//值为t 等同于 strings2.charAt(0)
```

## Boolean
这个类型只有两个值，保留字`true`和`false`

任何Javascript值都可以转换为布尔值。下面的值会直接被换成`false`：

`undefined`、`null`、`0`、`-0`、`NaN`、`""`（空字符串），所有其其他值都会转换为`true`。

+ `&&`运算符执行逻辑与操作，只有当两个操作数都是真值时它才会返回`true`,否则返回`false`。
+ `||`运算符布尔或操作，当两者中其中一个为真值时它就返回true，两个都为假值时返回`false`。
+ `!`布尔非操作，当操作数是真值时返回`false`，假值返回`true`。

## null与undefined
`null`是javascript的关键字，它表示一个特殊值。对`null`执行`typeof`运算，返回`object`。

如果要查询的对象属性或数组元素的值不存在时，则返回`undefined`；
当函数没有返回值时返回`undefined`；
引用没有提供实参的函数形参的值也只会得到`undefined`，`undefined`是一个*预定义的全局变量*。

```js
null == undefined;//值为true
```
要区分两者必须要用`===`来区分两者

## Object

### 包装对象
只要引用了字符串`s`的属性，Javascript就会将字符串值通过调用`new String(s)`的方式转换成临时字符串对象，这个对象继承了字符串原型对象的方法，并被用来处理属性的引用，一但引用结束，这个临时字符串对象就会被销毁。（`Number`和`Boolean`对象同理）

存取字符串、数字或布尔值的属性时创建的临时对象称做**包装对象**，包装对象通常只被看做是一种实现细节。（可以通过构造函数来创建包装对象）
```js
var s = "test",
    n = 1,
    b = true;
var S = new String(s);//是一个字符串对象
var N = new Number(n);
var B = new Boolean(b);
console.log(S == s, S === s, typeof S, typeof s);
//          true false object   string
```

## 两种类型的区别
```js
var o = {x: 1},
    p = {x: 1};
console.log(o == p);// false
```
两个具有相同属性的对象和数组永不相等。
对象和数组为引用类型，对象值都是引用，对象的比较均是引用的比较，当且仅当它们引用同一个基对象时，它们才相等。
```js
var a = [],
    b = a;
b[0] = 1;
console.log(a === b);//true
```
如果想得到一个对象或数组的副本，则必须显式复制对象的每一个属性或数组的每一个元素即所谓的**深复制**。