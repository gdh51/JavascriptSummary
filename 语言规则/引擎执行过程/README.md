# 引擎执行过程
*Javascript*引擎执行分为3个阶段：
1. **语法分析**：
   该阶段主要作用：
   >检查脚本语法是否正确，不正确就抛出语法错误(SyntaxError)，停止执行脚本代码；然后继续检查下一个代码块(每一个`<script>`标签就是一个代码块);如果语法正确，则进入预编译阶段
2. **预编译阶段**：
   当语法分析正确时就会进入预编译阶段,预编译阶段主要做了一件事：*创建执行上下文与相关变量*
3. **执行阶段**：顾名思义就是对代码进行解释执行

>浏览器首先按顺序加载由`<script>`标签分割的js代码块，加载js代码块完毕后，立刻进入以上三个阶段，然后再按顺序查找下一个代码块，再继续执行以上三个阶段

接下来便重点介绍一下创建执行上下文的过程。

## 执行环境
执行上下文是*Javascript*代码被解析和执行时所在环境的抽象概念

### 执行上下文类型
共三种类型：
+ **全局执行上下文**：共1个，浏览器全局对象就是`window`对象，`this`指向全局对象，在浏览器或网页被关闭后销毁(在不同环境中不一样,比如Node.js)
+ **函数执行上下文**：每当函数被调用时就会创建一个新的执行上下文，在函数执行完后销毁
+ **Eval函数执行上下文**：运行在`eval`函数中的代码

### 执行栈
执行栈也称为调用栈，具有栈结构(先进先出)，用于存储在代码执行期间创建的所有执行上下文。

过程：首次运行*Javascript*代码时，会创建一个全局执行上下文并推入当前执行栈中。**每当函数调用，就创建一个函数执行上下文并推入当前执行栈的最顶层。每当栈顶函数运行完成后，就会把对应的函数上下文弹出当前执行栈，并将上下文控制权转交给当前执行栈的下一个执行上下文**。

### 执行上下文的创建
执行上下文的创建分为两个阶段：
1. 创建阶段
2. 执行阶段

#### 创建阶段
在创建阶段只要做了三件事：
1. 确定`this`的值(This Binding)
2. 词法环境组件创建(LexicalEnvironment)
3. 变量环境组件创建(VariableEnvironment)

>后两个步骤也就是常说的*变量对象(VO)创建*，这个时候的变量对象不能访问只能在执行阶段进入这个执行上下文(此时变量对象转换为活动对象VO->AO)。

当进入一个函数执行上下文后，这个变量对象(VO)才会被激活为活动对象(AO),这时活动对象上的属性才可以被访问。

##### This Binding(确认this指向)
关于this的指向的确认分为两种情况：
+ 全局执行上下文中：`this`指向全局对象——浏览器中`this`指向`window`，nodejs中执行文件的`module`对象
+ 函数执行上下文中：`this`指向调用的对象

##### 词法环境组件 创建
词法环境由两部分组成
+ 环境记录(变量对象)：存储变量和函数声明的实际位置

+ 对外部环境的引用(作用域链)：可以访问外部词法环境

**建立作用域链**
作用域链由当前执行环境的变量对象（未进入执行阶段前）与上层环境的一系列活动对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。举个例子：
```js
function test() {
    var a = 10;

    function innerTest() {
        var b = 20;

        return a + b;
    }

    innerTest();
}

test();
```
当刚刚执行到`innerTest()`时(已进入该函数),此时活动对象就为`global`、`test`，变量对象为`innerTest`

词法环境分为两种：
+ **全局环境**：该环境没有外部环境引用(即为`null`)，环境记录中拥有一个全局对象和相关联的方法以及用户自定义的全局变量
+ **函数环境**：用户在函数中定义的变量会存储在环境记录中，包括`arguments`对象。对外部环境的引用可以是全局环境也可以是函数环境

##### 变量环境的创建
变量环境也是一个词法环境，所有它拥有词法环境的所有属性

在ES6中*变量环境*和*词法环境*的区别在于存储不同的变量声明，如变量环境存储通过`var`声明的变量，而词法环境存储`let`、`const`与函数声明的变量

在这里还要说明一点，在*变量环境*中，通过`var`声明的变量，会设置为`undefined`；在*词法环境*中，通过`let`与`const`声明的变量会保持**未初始化**状态，而函数声明会直接存储在环境中。这也是**变量提升**的原因。

#### 执行阶段
这个阶段会分为两步执行：
1. 进入执行上下文
   此时的变量对象会包括以下：
   + 函数中的所有形参：没有实参，属性值设为`undefined`
   + 函数声明：如果变量对象存在同名属性，替换掉
   + 变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明**不会干扰**已经存在的这类属性。
2. 执行代码

[参考1](https://juejin.im/entry/5bf3d23d5188255e9b61a56f)
[参考2](https://heyingye.github.io/2018/03/19/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/)

### 作用域链
当访问一个变量时，解释器会首先在当前作用域查找标识符，如果没有找到，就去父作用域查找，如此往复找到为止，直到全局作用域，如果还没找到就会抛出`ReferenceError`。

与原型链区别：对象上的属性在自身和原型上不存在时会显示为`undefined`

所以作用域链就是：每个函数都有自己的执行上下文环境，当代码在这个环境中执行时，会创建变量对象的作用域链，作用域链是一个对象列表或对象链，它保证了变量对象的有序访问。

#### 作用域
指一个变量和函数的作用范围

#### 闭包
MDN定义：闭包指那些能访问自由变量的函数。(自由变量指在函数中使用，但既不是函数参数`aruguments`也不是函数的局部变量的变量，而是另一个函数作用域中的变量)
即：
1. 是一个函数
2. 能访问上级函数作用域的变量(即使上级函数上下文已经销毁)

原理：当一个嵌套函数返回的内部函数执行时访问一个父级世属性，该函数会通过自身的作用域链向上级作用域查找其父级的活动对象上的属性。

## 内存空间
Javascript内存空间分为栈、堆、池。其中栈存放变量，堆存放复杂对象，池存放常量。

### 变量的存放
内存中有栈和堆，变量更具类型分别存储在两个地方：
+ **基本类型**：保存在栈内存中，因为这些类型在内存中分别占有固定大小的空间，通过按值来访问。基本类型一共6种：`Undefined`、`Null`、`Boolean`、`Number`、`String`、`Symbol`

+ **引用类型**：保存在堆内存中，因为这种值的大小不固定，因此不能把它们保存在栈内存，但内存地址大小是固定的，因此对象中的值保存在堆内存中。**当查询引用类型的变量时，先从栈中读取内存地址，然后再通过地址找到堆中的值**。

### 内存空间管理
Javascript内存生命周期为：
1. 分配所需内存
2. 使用分配到的内存(读、写)
3. 不需要时释放、归还

Javascript有自动垃圾收集机制，最常用的是标记清除算法，当一个对象不再被引用时，在下一次垃圾回收时就会被回收。

#### 内存回收
Javascript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作。
+ 局部变量和全局变量的销毁
  + 局部变量：局部作用域中，当函数执行完毕，局部变量会被垃圾收集器回收
  + 全局变量：全局变量的回收需要判断，要避免使用全局变量
+ Google V8引擎中所有对象都是通过堆来进行内存分配的
  + 初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量
  + 继续申请：当已申请内存不足以存储这个变量时，V8就会继续申请内存，直到堆的大小达到V8引擎内存上限
+ V8对堆内存中的对象进行分代管理
  + 新生代：存活周期较短的对象，如临时变量、字符串等
  + 老生代：经过多次垃圾回收仍然存活，存活周期较长的对象。

#### 垃圾回收算法
+ 引用计数（已不再使用）：当一个对象没有引用指向它时就在下一轮清除。
  这种算法存在的问题就是当两个对象互相引用时，即使它们不在被使用也不会回收(IE还在继续使用)
+ 标记清除(常用)：标记清楚将*不再使用的对象*定义为*无法到达的对象*，即从根部(在JS中为全局对象)出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。无法到达的对象被标记为不再使用，稍后回收。

#### 内存泄漏
持续运行的服务进程，必须及时释放不再用到的内存。否则内存占用会越来越高，轻则影响系统性能，重则导致进程崩溃。对于不再用到的内存，没有及时释放，就在内存泄漏。

##### 常见的内存泄漏
1. 意外的全局变量：函数中未使用`var`定义的变量或不正确使用`this`定义的变量
   >解决方法：全局使用严格模式

2. 被遗忘的计时器或回调函数：计时器引用了已经被移除的对象或移除了一个对象但回调中该对象被引用
   >解决方法：停止计数器，第二种情况现在除旧版IE外不存在了

3. 脱离DOM的引用：当把DOM作为变量或对象属性存储时，此时该DOM元素存在两个引用：一个在DOM树中，一个作为变量。在不用时，必须都要解除这两个引用

4. 闭包：可以访问父级作用域的变量
   >解决方法：在不用时清除父级作用域中的变量


##### 内存泄漏识别方法
1. 浏览器(由于浏览器更新可能不在当前位置, 目前在`Performance`)
   1. 打开开发者工具，选择`Performance`
   2. 在下方的多选中勾选`Memory`
   3. 点击左上角的录制按钮
   4. 在页面上进行操作，模拟用户使用情况
   5. 一段时间后点击左上角`stop`按钮，面板上会显示这段时间内存占用情况
2. 命令行方法
   使用Node.js提供的`process.memoryUsage`方法
   ```js
   process.memoryUsage();
   //输出：一个对象
   {
     rss:111111,//所有内存占用，包括指令区和堆栈
     heapTotal: 56565,//堆占用的内存
     heapUsed: 33333,//用到的堆内存
     external: 8888 //V8引擎内部的C++对象占用的内存
   }
   ```

## 浏览器的进程与线程
[跳转？！！@##%￥……&￥*￥](./浏览器的进程与线程)
