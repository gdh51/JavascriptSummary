# 引擎执行过程

*Javascript*引擎执行分为3个阶段：

1. **语法分析**：检查脚本语法是否正确，不正确就抛出语法错误(`SyntaxError`)，停止执行脚本代码；然后继续检查下一个代码块(每一个`<script>`标签就是一个代码块)；如果语法正确，则进入预编译阶段
2. **预编译阶段**：当语法分析正确时就会进入预编译阶段,预编译阶段主要做了一件事：**创建执行上下文与相关变量**
3. **执行阶段**：顾名思义就是对代码进行解释执行

>浏览器首先按顺序加载由`<script>`标签分割的js代码块，加载js代码块完毕后，立刻进入以上三个阶段，然后再按顺序查找下一个代码块，再继续执行以上三个阶段

接下来便重点介绍一下创建执行上下文的过程。

## 执行环境

执行上下文是*Javascript*代码**被解析和执行时所在环境**的抽象概念，它共三种类型：

+ **全局执行上下文**：共1个，浏览器中的全局对象就是`window`对象，`this`指向全局对象，在浏览器或网页被关闭后销毁(在不同环境中不一样，比如`Node.js`，指代当前模块对象)
+ **函数执行上下文**：每当函数被调用时就会创建一个新的执行上下文，在函数执行完后销毁
+ **eval函数执行上下文**：运行在`eval()`函数中的代码

### 执行栈

执行栈也称为调用栈，具有**栈**结构(先进先出)，用于存储在代码执行期间创建的所有执行上下文。

大致运行的过程为：首次运行*Javascript*代码时，会创建一个全局执行上下文并推入当前执行栈中。**每当函数调用，就创建一个函数执行上下文并推入当前执行栈的最顶层。每当栈顶函数运行完成后，就会把对应的函数上下文弹出当前执行栈，并将上下文控制权转交给当前执行栈的下一个执行上下文**。

![Call Stack](./imgs/call&#32;stack.png)

### 执行上下文的创建

执行上下文的创建分为两个阶段：

1. [创建阶段](#%e5%88%9b%e5%bb%ba%e9%98%b6%e6%ae%b5)
2. [执行阶段](#%e6%89%a7%e8%a1%8c%e9%98%b6%e6%ae%b5)

#### 创建阶段

在创建阶段只要做了三件事：

1. [确定`this`的值(`This Binding`)](#this-binding%e7%a1%ae%e8%ae%a4this%e6%8c%87%e5%90%91)
2. [词法环境组件创建(`LexicalEnvironment`)](#%e8%af%8d%e6%b3%95%e7%8e%af%e5%a2%83%e7%bb%84%e4%bb%b6-%e5%88%9b%e5%bb%ba)
3. [变量环境组件创建(`VariableEnvironment`)](#%e5%8f%98%e9%87%8f%e7%8e%af%e5%a2%83%e7%9a%84%e5%88%9b%e5%bb%ba)

>后两个步骤也就是常说的**创建变量对象(VO)**，这个时候的变量对象不能访问只能在执行阶段进入这个执行上下文(此时变量对象转换为活动对象`VO->AO`)。

当进入一个函数执行上下文后(或调用栈的上下文控制权转交给这个函数)，这个变量对象(`VO`)才会被激活为活动对象(`AO`),这时活动对象上的属性才可以被访问。

##### This Binding(确认this指向)

关于`this`的指向的确认分为两种情况：

+ 全局执行上下文中：`this`指向全局对象——浏览器中`this`指向`window`，nodejs中执行文件的`module`对象
+ 函数执行上下文中：`this`指向调用的对象

##### 词法环境组件 创建

词法环境由两部分组成

+ 环境记录(变量对象)：存储变量和函数声明的实际位置
+ 对外部环境的引用(作用域链)：可以访问外部词法环境

##### 建立作用域链

作用域链由当前执行环境的变量对象（未进入执行阶段前）与上层环境的一系列活动对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。举个例子：

```js
var a = 5;
function test() {
    var a = 10;

    function innerTest() {
        var b = 20;

        return a + b;
    }

    innerTest();
}

test();
```

当刚刚执行到`innerTest()`时(已进入该函数),此时活动对象就为`global`、`test`，变量对象为`innerTest`。所以调用`test()`时的作用域链为：`innerTest -> test -> global`(由内到外)，所以我们访问在执行`a + b`时，会先从`test`的变量对象中寻找`a`变量，而不是`global`。
____

词法环境分为两种：

+ **全局环境**：该环境没有外部环境引用(即为`null`)，环境记录中拥有一个全局对象和相关联的方法以及用户自定义的全局变量
+ **函数环境**：用户在函数中定义的变量会存储在环境记录中，包括`arguments`对象。对外部环境的引用可以是全局环境也可以是函数环境

##### 变量环境的创建

变量环境也是一个词法环境，所以它拥有词法环境的所有属性

在ES6中*变量环境*和*词法环境*的区别在于**存储不同的变量声明**：如变量环境存储通过`var`声明的变量，而词法环境存储`let`、`const`与函数声明的变量

在这里还要说明一点，在*变量环境*中，通过`var`声明的变量，会设置为`undefined`；在*词法环境*中，通过`let`与`const`声明的变量会保持**未初始化**状态，而函数声明会直接存储在环境中。这也是**变量提升**的原因。

#### 执行阶段

这个阶段会分为两步执行：

1. 进入执行上下文
   此时的变量对象会包括以下：
   + 函数中的所有形参：没有实参，属性值设为`undefined`
   + 函数声明：如果变量对象存在同名属性，替换掉
   + 变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明**不会干扰**已经存在的这类属性。
2. 执行代码

[参考1](https://juejin.im/entry/5bf3d23d5188255e9b61a56f)
[参考2](https://heyingye.github.io/2018/03/19/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/)

### 作用域链

上面我们提到，[作用域链由多个活动对象和变量对象组成](#%e5%bb%ba%e7%ab%8b%e4%bd%9c%e7%94%a8%e5%9f%9f%e9%93%be)。那么一个作用域链如何进行变量访问呢？

当访问一个变量时，解释器会首先在当前作用域查找标识符，如果没有找到，就去父作用域查找，如此往复找到为止，直到全局作用域，如果还没找到就会抛出`ReferenceError`。

与原型链区别：对象上的属性在自身和原型上不存在时会显示为`undefined`

所以再次总结作用域链就是：每个函数都有自己的执行上下文环境，当代码在这个环境中执行时，会创建变量对象的作用域链，作用域链是一个对象列表或对象链，它保证了变量对象的有序访问。

#### 作用域

指一个变量和函数的作用范围

#### 闭包

MDN定义：闭包指那些能访问自由变量的函数。(自由变量指在函数中使用，但既不是函数参数`aruguments`也不是函数的局部变量的变量，而是另一个函数作用域中的变量)
即：

1. 是一个函数
2. 能访问上级函数作用域的变量(即使上级函数上下文已经销毁)

原理：函数与对其状态即词法环境（`lexical environment`）的引用共同构成闭包（`closure`）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在`JavaScript`，函数在每次创建时生成闭包，所以闭包的产生是因为**词法作用域**。

## 内存空间

`Javascript`内存空间分为栈、堆、池。其中栈存放变量，堆存放复杂对象，池存放常量。

### 变量的存放

内存中有栈和堆，变量更具类型分别存储在两个地方：

+ **基本类型**：保存在栈内存中，因为这些类型在内存中分别占有**固定大小**的空间，通过按值来访问。基本类型一共6种：`Undefined`、`Null`、`Boolean`、`Number`、`String`、`Symbol`

+ **引用类型**：保存在堆内存中，因为这种值的大小不固定，因此不能把它们保存在栈内存，但内存地址大小是固定的，因此对象中的值保存在堆内存中。**当查询引用类型的变量时，先从栈中读取内存地址，然后再通过地址找到堆中的值**。

### 内存空间管理

`Javascript`内存生命周期为：

1. 分配所需内存
2. 使用分配到的内存(读、写)
3. 不需要时释放、归还

`Javascript`有自动垃圾收集机制，最常用的是标记清除算法，当一个对象不再被引用时，在下一次垃圾回收时就会被回收。

#### 内存回收

`Javascript`有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作。

+ 局部变量和全局变量的销毁
  + 局部变量：局部作用域中，当函数执行完毕，局部变量会被垃圾收集器回收
  + 全局变量：全局变量的回收需要判断，要避免使用全局变量
+ `Google V8`引擎中所有对象都是通过堆来进行内存分配的
  + 初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量
  + 继续申请：当已申请内存不足以存储这个变量时，V8就会继续申请内存，直到堆的大小达到V8引擎内存上限
+ V8对堆内存中的对象进行分代管理
  + 新生代：存活周期较短的对象，如临时变量、字符串等
  + 老生代：经过多次垃圾回收仍然存活，存活周期较长的对象。

#### 垃圾回收算法

+ 引用计数（已不再使用）：当一个对象没有引用指向它时就在下一轮垃圾回收时清除。
  这种算法存在的问题就是当两个对象互相引用时，即使它们不在被使用也不会回收(IE还在继续使用)
+ 标记清除(常用)：标记清除将*不再使用的对象*定义为*无法到达的对象*，即从根部(在JS中为全局对象)出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。无法到达的对象被标记为不再使用，稍后回收。

[更多关于垃圾回收机制](../../BOM,DOM/BOM/浏览器内存管理/README.md)

#### 内存泄漏

持续运行的服务进程，必须及时释放不再用到的内存。否则内存占用会越来越高，轻则影响系统性能，重则导致进程崩溃。对于不再用到的内存，没有及时释放，就在内存泄漏。

##### 常见的内存泄漏

1. 意外的全局变量：函数中未使用`var`定义的变量或不正确使用`this`定义的变量
   >解决方法：全局使用严格模式

2. 被遗忘的计时器或回调函数：计时器引用了已经被移除的对象或移除了一个对象但回调中该对象被引用
   >解决方法：停止计数器，第二种情况现在除旧版IE外不存在了

3. 脱离`DOM`的引用：当把`DOM`作为变量或对象属性存储时，此时该`DOM`元素存在两个引用：一个在`DOM`树中，一个作为变量。在不用时，必须都要解除这两个引用

4. 闭包：可以访问父级作用域的变量
   >解决方法：在不用时清除父级作用域中的变量

##### 内存泄漏识别方法

1. 浏览器(由于浏览器更新可能不在当前位置, 目前在`Performance`)
   1. 打开开发者工具，选择`Performance`
   2. 在下方的多选中勾选`Memory`
   3. 点击左上角的录制按钮
   4. 在页面上进行操作，模拟用户使用情况
   5. 一段时间后点击左上角`stop`按钮，面板上会显示这段时间内存占用情况

2. 命令行方法
   使用`Node.js`提供的`process.memoryUsage`方法

   ```js
   process.memoryUsage();
   //输出：一个对象
   {
     rss:111111,//所有内存占用，包括指令区和堆栈
     heapTotal: 56565,//堆占用的内存
     heapUsed: 33333,//用到的堆内存
     external: 8888 //V8引擎内部的C++对象占用的内存
   }
   ```

## 浏览器的进程与线程

[跳转？！！@##%￥……&￥*￥](./浏览器线程与进程/README.md)
