# Javascript语言规则

## 引擎执行过程
javascript引擎执行分为3个阶段：
1. 语法分析：
   该阶段主要作用：检查脚本语法是否正确，不正确就抛出语法错误(SyntaxError)，停止执行脚本代码；然后继续检查下一个代码块(每一个`<script>`标签就是一个代码块);如果语法正确，则进入编译阶段
2. 预编译阶段
3. 执行阶段

### 执行环境
执行上下文是javascript代码被解析和执行时所在环境的抽象概念

#### 执行上下文类型
共三种类型：
+ 全局执行上下文：共1个，浏览器全局对象就是`window`对象，`this`指向全局对象，在浏览器或网页被关闭后销毁
+ 函数执行上下文：每当函数被调用时就会创建一个新的执行上下文，在函数执行完后销毁
+ Eval函数执行上下文：运行在`eval`函数中的代码

#### 执行栈
执行栈也称为调用栈，具有栈结构(先进先出)，用于存储在代码执行期间创建的所有执行上下文。

过程：首次运行javascript代码时，会创建一个全局执行上下文并推入当前执行栈中。*每当函数调用*，就创建一个函数执行上下文并推入当前执行栈的最顶层。每当栈顶函数运行完成后，就会把对应的函数上下文弹出当前执行栈，并将上下文控制权转交给当前执行栈的下一个执行上下文。

#### 执行上下文的创建
执行上下文的创建分为两个阶段：1. 创建阶段 2.执行阶段

##### 创建阶段
1. 确定`this`的值(This Binding)
2. 词法环境组件创建(LexicalEnvironment)
3. 变量环境组件创建(VariableEnvironment)

后两个步骤也就是 常说的*创建变量对象*,这个时候的变量对象不能访问只能在执行阶段进入这个执行上下文(此时变量对象转换为活动对象V0->AO)。

当进入一个函数执行上下文后，这个变量对象(VO)才会被激活为活动对象(AO),这时活动对象上的属性才可以被访问。

**This Binding**：分为两种情况：
+ 全局执行上下文中：`this`指向全局对象——浏览器中`this`指向`window`，nodejs中执行文件的`module`对象
+ 函数执行上下文中：`this`指向调用的对象

**词法环境**
由两部分组成
+ 环境记录(变量对象)：存储变量和函数声明的实际位置

+ 对外部环境的引用(作用域链)：可以访问外部词法环境

**建立作用域链**
作用域链由当前执行环境的变量对象（未进入执行阶段前）与上层环境的一系列活动对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。举个例子：
```js
var num = 30;

function test() {
    var a = 10;

    function innerTest() {
        var b = 20;

        return a + b
    }

    innerTest()
}

test()
```
当刚刚执行到`innerTest()`时(已进入该函数),此时活动对象就为`global`、`test`，变量对象为`innerTest`

词法环境分为两种：
+ 全局环境：该环境没有外部环境引用(即为`null`)，环境记录中拥有一个全局对象和相关联的方法以及用户自定义的全局变量
+ 函数环境：用户在函数中定义的变量会存储在环境记录中，包括`arguments`对象。对外部环境的引用可以是全局环境也可以是函数环境

**变量环境**
变量环境也是一个词法环境，所有它拥有词法环境的所有属性

在ES6中*变量环境*和*词法环境*的区别在于存储不同的变量声明，如变量环境存储通过var声明的变量，而词法环境存储`let`、`const`与函数声明的变量

在这里还要说明一点，在*变量环境*中，通过`var`声明的变量，会设置为`undefined`；在*词法环境*中，通过`let`与`const`声明的变量会保持**未初始化**状态，而函数声明会直接存储在环境中。这也是**变量提升**的原因。

##### 执行阶段
这个阶段会分为两步执行：
1. 进入执行上下文
   此时的变量对象会包括以下：
   + 函数中的所有形参：没有实参，属性值设为undefined
   + 函数声明：如果变量对象存在同名属性，替换掉
   + 变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明**不会干扰**已经存在的这类属性。
2. 执行代码

[参考1](https://juejin.im/entry/5bf3d23d5188255e9b61a56f)
[参考2](https://heyingye.github.io/2018/03/19/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/)

#### 作用域链
当访问一个变量时，解释器会首先在当前作用域查找标识符，如果没有找到，就去父作用域查找，如此往复找到为止，直到全局作用域，如果还没找到就会抛出ReferenceError。

与原型链区别：对象上的属性在自身和原型上不存在时会显示为undefined

所以作用域链就是：每个函数都有自己的执行上下文环境，当代码在这个环境中执行时，会创建变量对象的作用域链，作用域链是一个对象列表或对象链，它保证了变量对象的有序访问。

##### 作用域
指一个变量和函数的作用范围

##### 闭包
MDN定义：闭包指那些能访问自由变量的函数。(自由变量指在函数中使用，但既不是函数参数aruguments也不是函数的局部变量的变量，而是另一个函数作用域中的变量)
即：
1. 是一个函数
2. 能访问上级函数作用域的变量(即使上级函数上下文已经销毁)

原理：当一个嵌套函数返回的内部函数执行时访问一个父级世属性，该函数会通过自身的作用域链向上级作用域查找其父级的活动对象上的属性。

### 内存空间
Javascript内存空间分为栈、堆、池。其中栈存放变量，堆存放复杂对象，池存放常量。

#### 变量的存放
内存中有栈和堆，变量更具类型分别存储在两个地方：
+ 基本类型：保存在栈内存中，因为这些类型在内存中分别占有固定大小的空间，通过按值来访问。基本类型一共6种：`Undefined`、`Null`、`Boolean`、`Number`、`String`、`Symbol`

+ 引用类型：保存在堆内存中，因为这种值的大小不固定，因此不能把它们保存在栈内存，但内存地址大小是固定的，因此保存在堆内存中。*当查询引用类型的变量时，先从栈中读取内存地址，然后再通过地址找到堆中的值*。

#### 内存空间管理
Javascript内存生命周期为：
1. 分配所需内存
2. 使用分配到的内存(读、写)
3. 不需要时释放、归还

Javascript有自动垃圾收集机制，最常用的是标记清除算法，当一个对象不再被引用时，在下一次垃圾回收时就会被回收。

##### 内存回收
Javascript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作。
+ 局部变量和全局变量的销毁
  + 局部变量：局部作用域中，当函数执行完毕，局部变量会被垃圾收集器回收
  + 全局变量：全局变量的回收需要判断，要避免使用全局变量
+ Google V8引擎中所有对象都是通过堆来进行内存分配的
  + 初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量
  + 继续申请：当已申请内存不足以存储这个变量时，V8就会继续申请内存，直到堆的大小达到V8引擎内存上限
+ V8对堆内存中的对象进行分代管理
  + 新生代：存活周期较短的对象，如临时变量、字符串等
  + 老生代：经过多次垃圾回收仍然存活，存活周期较长的对象。

##### 垃圾回收算法
+ 引用计数（已不再使用）：当一个对象没有引用指向它时就在下一轮清除。
  这种算法存在的问题就是当两个对象互相引用时，即使它们不在被使用也不会回收(IE还在继续使用)
+ 标记清除(常用)：标记清楚将*不再使用的对象*定义为*无法到达的对象*，即从根部(在JS中为全局对象)出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。无法到达的对象被标记为不再使用，稍后回收。

##### 内存泄漏
持续运行的服务进程，必须及时释放不再用到的内存。否则内存占用会越来越高，轻则影响系统性能，重则导致进程崩溃。对于不再用到的内存，没有及时释放，就在内存泄漏。

常见的内存泄漏：
1. 意外的全局变量：函数中未使用var定义的变量或不正确使用`this`定义的变量
   解决方法：全局使用严格模式

2. 被遗忘的计时器或回调函数：计时器引用了已经被移除的对象或移除了一个对象但回调中该对象被引用
   解决方法：停止计数器，第二种情况现在除旧版IE外不存在了

3. 脱离DOM的引用
   当把DOM作为变量或对象属性存储时，此时该DOM元素存在两个引用：一个在DOM树中，一个作为变量。在不用时，必须都要解除这两个引用

4. 闭包：可以访问父级作用域的变量
   解决方法：在不用时清除父级作用域中的变量


内存泄漏识别方法
1. 浏览器
   1. 打开开发者工具，选择`Memory`
   2. 在右侧的`Select profiling type`中勾选`timeline`
   3. 点击左上角的录制按钮
   4. 在页面上进行操作，模拟用户使用情况
   5. 一段时间后点击左上角stop按钮，面板上会显示这段时间内存占用情况
2. 命令行方法
   使用Node提供的`process.memoryUsage`方法
   ```js
   process.memoryUsage();
   //输出：一个对象
   {
     rss:111111,//所有内存占用，包括指令区和堆栈
     heapTotal: 56565,//堆占用的内存
     heapUsed: 33333,//用到的堆内存
     external: 8888 //V8引擎内部的C++对象占用的内存
   }
   ```


## 标识符规则

### 标识符命名
javascript中表达式必须以*字母*、*下划线*或*美元符号*开始，后续字符可以是字母、数字、下划线或美元符号。
javascript标识符中还可以包含Unicode字符集中的字母和数字。

当出现标识符时，javasript会将其当作变量而去查找它的值。变量名不存在则运算结果为`undefined`.

### 变量
变量是标识符的一种。
#### 变量声明
用`var`声明了变量但未赋值，则它的初始值为`undefined`。

变量声明分为 **定义**、**初始化**、**赋值** 三个阶段

##### 作为属性的变量
当声明一个javasript全局变量时，实际上是定义了全局对象的一个属性————当使用`var`声明一个变量时，创建时这个属性是不可配置的，这个变量无法通过`delete`运算符删除。
当给一个**未声明**的变量赋值时， javacript会创建一个全局变量。以这种方式创建的变量是全局对象的正常的可配值属性（可删除）

#### 变量作用域
局部变量的优先级高于全局变量。

局部变量可以当作跟函数相关的某个对象的属性，成为声明上下文对象。

javasript是基于词法作用域：**通过阅读包含变量定义在内的数行源码就能知道变量的作用域**

#### 函数作用域和声明提前
类C语言中，花括号内的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的，这种称之为块级作用域。javasript没有块级作用域（ES6之前）

javasript拥有函数作用域：*变量在声明它们的函数以及这个函数体嵌套的任意函数体内都是有定义的。*

**变量提升**：变量声明后，变量会立即进行定义和初始到当前作用域顶部（即声明之前就已有该变量），如下例：
```js
var scope="global";
function f() {
  console.log(scope);//输出undefined
  var scope="local";//变量在这里赋初始值，但变量在函数体内任何地方都有定义
  console.log(scope);//local
}
```

## 符号规则

### 分号(;)
如果当前语句和随后的*非空格字符*不能当成一个整体来解析时，javascript会在当前语句行结束处填补分号。如：
```js
var y=x+f
(a + b).toString() //javascript解析为var y=x+f(a + b).toString(),相当于f被解析为函数
```

但在某些情况下会不一样：
+ `return` `break` `continue` : 它们会直接在后面添加分号
```js
  function test(a) {
    return
    a;
  }
  test(1);//undefined
```

+ `++` `--` : 它们会自动应用于下一句语句

如：
```js
  //以下语句解析为 x; ++y 本意为 x++; y
  x
  ++
  y
```

通常来将，如果一条语句以`( [ / + -`开始，那么它极有可能和前一条语句一起解析。（解决方法可以在这些符号前显示添加;号）



## 数据类型
Javascript的数据类型分为两类：**原始类型**和**引用类型**

原始类型分为：`Number`、`String`、`Boolean`、`null`、`undefined` 、(ES6新增)`Symbol` ，它们都是不可变类型
引用类型为：`Object`

### Number
由于Javascript采用IEE-754浮点数表示法，是一种二进制表示法，占用64bit，不能精准的表示类似0.1之类的简单数字，所以你会看到如下情况：
```js
var x=0.3-0.2;//0.099999999999998
var y=0.2-0.1;//0.1
console.log(x==y);//false

1.335.toFixed(2); // 1.33

var x = 9007199254740992
x + 1 == x // true
```

在这64bit中其中 第1位用来表示符号位 2~11位表示指数(共11位,偏移值为1023) 12~64位表示尾数(即有效域,共52位)

*指数*永远为一个非负数,减去偏移值后才为正真的指数,所以指数域的取值为 0 <= e <= 2<sup>11</sup>,
真正的指数就为 -1023 <= E <= 1024

*尾数*表示有效域部分，只能存储52位的数字，多余的自动去除。在二进制科学计数法中，要保证小数点前必须有一位非0数,那么有效域必然为1.XXXX,这种样子的二进制被称为*规格化的*，这种二进制存储时，1.默认不占尾数位置,尾数部分从第一个X开始;当一个二进制小数无限接近于0时，如要保持1.XXXX的形式，那么指数部分必然取-1023,但如果取该指数值都没能达到1.XXXX的形式，那么只能用0.XXXX来表示有效部分,这样的二进制被称为*非规格化的*


一个数用公式来表示就为 x = (-1)<sup>s</sup> x (1.尾数) x 2<sup>(指数域 - 偏移量)</sup>

其中s表示符号位,所有的数值都按照此公式计算

0.1的二进制为0.0 0011 0011 0011..(循环0011)
0.2的二进制为0.0011 0011 0011..(0011无限循环)
此处精度丢失的原因在于相加后舍去了双方后面的循环,它们超过了52位尾数

大整数的精度丢失和浮点数本质上是一样的，尾数位最大是52位，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，十进制即 9007199254740992。(上述第二种情况) 超出这个范围就不能保证精度问题了

解决方法：
1. 不超出精度范围(64)
2. 自行转换，如下：
```js
function numAdd(num1/*:String*/, num2/*:String*/) {
    var baseNum, baseNum1, baseNum2;
    try {
        //取得第一个操作数小数点后有几位数字，注意这里的num1是字符串形式的
        baseNum1 = num1.split(".")[1].length;
    } catch (e) {
        //没有小数点就设为0
        baseNum1 = 0;
    }
    try {
        //取得第二个操作数小数点后有几位数字
        baseNum2 = num2.split(".")[1].length;
    } catch (e) {
        baseNum2 = 0;
    }
    //计算需要 乘上多少数量级 才能把小数转化为整数
    baseNum = Math.pow(10, Math.max(baseNum1, baseNum2));
    //把两个操作数先乘上计算所得数量级转化为整数再计算，结果再除以这个数量级转回小数
    return (num1 * baseNum + num2 * baseNum).toFixed(0) / baseNum;
};
```

[部分引用](https://segmentfault.com/a/1190000009084877#articleHeader1)

### String
Javascript中文本由一组16位值组成的不可变的有序序列，每个字符通常来自于Unicode字符集。

*字符串的长度是其所含16位值的个数*。

最常用的Unicode字符都是通过16位内码表示，并代表字符串中的单个字符，那些不能表示为16位的Unicode字符遵循UTF-16编码规则——用两个16位值组成的一个序列（*代理项对*）表示。这意味着一个长度为2的Javascript字符串有可能能表示一个Unicode字符：
```js
var p="π";//长度为1   16位内码为0x03c0
var e="𝑒";//长度为2   17位内码为0x1d452
//e通过UTF-16编码后包含两个16位值:"\ud835\udc52"
```

Javascript定义的各种字符串操作方法均作用于16位值而非字符（ES6之前），且不会对*代理项对*做单独处理，同样Javascript不会对字符串做标准化的加工，甚至不能保证字符串是合法的UTF-16格式

#### 字符串直接量
字符串可以拆分为数行，且每行必须以` \ `结束，（` \ `与` \n `都不算字符串的直接量内容）当想字符串直接量另起一行时可以使用转义字符（` \n `）
```js
var strings="two\
lines"  //这是一个单行代码表示  twolines
```

#### 转义字符
` \ `后加一个字符，就不再表示它们的字面含义了。

#### 字符串的加法
当用` + `运算符作用于字符串时，表示将第二个字符串拼接在第一个之后

要确认一个字符串的长度——其所包含的16位值的个数——可以用字符串的`length`属性

**Javascript中字符串是固定不变的，某些方法都是返回新的字符串，原字符串本身并没有发生改变**。

字符串可以作为只读数组，除了使用charAt()，还可以直接通过方括号来访问字符串中的单个字符（16位值）：
```js
strings2='twossss';
strings2[0];//值为t 等同于 strings2.charAt(0)
```

### Boolean
这个类型只有两个值，保留字`true`和`false`

任何Javascript值都可以转换为布尔值。下面的值会直接被换成false：

`undefined`、`null`、`0`、`-0`、`NaN`、`""`（空字符串），所有其其他值都会转换为true。

`&&`运算符执行逻辑与操作，只有当两个操作数都是真值时它才会返回true,否则返回false。
`||`运算符布尔或操作，当两者中其中一个为真值时它就返回true，两个都为假值时返回false。
`!`布尔非操作，当操作数是真值时返回false，假值返回true。

### null与undefined
`null`是javasript的关键字，它表示一个特殊值。对`null`执行`typeof`运算，返回`object`。

如果要查询的对象属性或数组元素的值不存在时，则返回`undefined`；
当函数没有返回值时返回`undefined`；
引用没有提供实参的函数形参的值也只会得到`undefined`，`undefined`是一个*预定义的全局变量*。

```js
null==undefined;//值为true
```
要区分两者必须要用`===`来区分两者

### Object

#### 包装对象
只要引用了字符串`s`的属性，javasript就会将字符串值通过调用`new String(s)`的方式转换成临时字符串对象，这个对象继承了字符串原型对象的方法，并被用来处理属性的引用，一但引用结束，这个临时字符串对象就会被销毁。（`Number`和`Boolean`对象同理）

存取字符串、数字或布尔值的属性时创建的临时对象称做**包装对象**，包装对象通常只被看做是一种实现细节。（可以通过构造函数来创建包装对象）
```js
var s = "test",n = 1,b = true;
var S = new String(s);//是一个字符串对象
var N = new Number(n);
var B = new Boolean(b);
console.log(S == s, S === s, typeof S, typeof s);
//          true false object   string
```

### 两种类型的区别
```js
var o = {x: 1},p = {x: 1};
console.log(o == p);//false
```
两个具有相同属性的对象和数组永不相等。
对象和数组为引用类型，对象值都是引用，对象的比较均是引用的比较，当且仅当它们引用同一个基对象时，它们才相等。
```js
var a = [];
var b = a;
b[0] = 1;
console.log(a === b);//true
```
如果想得到一个对象或数组的副本，则必须显式复制对象的每一个属性或数组的每一个元素即所谓的**深复制**。

## 运算规则

### 类型转换
此处列举几个特殊的类型转换：
`null`、`""`（空字符串）、`[]`（任意空数组）转换为数字时为0。
`[9]`含有一个数字元素的数组会转换为数字时会转换为其中的数字元素值（*先转换为字符串然后转换为数字*）

当原始值转换为对象时调用它们对应的构造函数。（`null`、`undefined`会导致错误）

#### 显示类型转换
当不通过`new`调用`Boolean()`、`Number()`、`String()`、`Object()`构造函数时，他们会作为类型转换函数，并按照上面的规则转换。

除了`null`、`undefined`外的任何值都具有`toString()`方法（与`String()`方法相似）。
(调用`new Object(null or undefined)`会生成一个空对象，这是特殊情况)

#### 隐式类型转换
如`+`运算符的一个操作数是字符串，它将会把另一个操作数也转换为字符串。
一元`+`运算符会将其操作数转换为数字。一元`！`操作符会将操作数转换为布尔值取反。
```js
x+""//等价String(x)
+x//等价与Number(x)
!!x//等级于Boolean(x)
```

`+`和`==`应用到对象到原始值的转换包含*日期对象*的一种特殊情形。对于非日期对象，对象到原始值的转换基本上是对象到数字的转换，而日期对象则使用对象到字符串的转换模式。
日期对象使用对象到字符串的转换。

`<`运算符及其他运算符（除去日期对象）：任何对象首先尝试`valueOf()`，然后调用`toString()`，*不管得到的原始值是否能直接使用，它都不会进一步被转换为数字或字符串*。

`+`,`==`,`!=`是唯一执行将到上述特殊字符串转换为原始值的运算符。
其他运算符到特定类型的转换都很明确：`-`运算符把两个操作数都转换为数字。

```js
var now=new Date();
now+1;//string
now-1;//number
now==now.toString();//隐式和显式的字符串转换
now>(now-1);//>将日期转化为数字
```

#### 其他转换方式
Javascript提供了专门的函数和方法来做更加精准的*数字到字符串*和*字符串到数字*的转换：

`Number`类定义了`toString()`方法接收表示转换基数的可选参数（2~36之间），如果不指定参数则按十进制进行转换。
`toFixed(位数)`根据小数点后的指定位数将数字转化为字符串。
`toExponential(位数)`使用指数记数法将数字转换为指数形式的字符串。
`toPrecision(位数)`根据指定的有效数字位数将数字转换为字符串。
三种方法都会适当的进行四舍五入
```js
let c = 123456.789;
c.toFixed(5);//123456.78900  保留5位小数的字符串
c.toExponential(3);//1.235e+5  保留3位小数的字符串
c.toPrecision(10);//123456.7890 共10位数字的字符串
```

如果向`Number()`转换函数传入一个字符串，它会尽量转换为一个整数或浮点数直接量（基于10进制）（唯有纯数字字符串或者带一个`.`才能转换为数字）

利用*全局函数*转换

`parseInt(string, [进制])`：只解析为整数（解析字符串），可选择传入第二个参数表示转换的进制。（2~36）（为0时为十进制，其他的时候返回`NaN`）如果字符串的前缀是0x或0X，则`parseInt`会将其解释为16进制数

`parseFloat()`：只解析为整数与浮点数（解析字符串），可接收第二个参数表示转换的进制。

#### 具体的转换过程

##### 对象转换为原始值
+ 对象转换为布尔值：所有对象都转换为`true`,即使是`new Boolean(false)`也转换为`true`

+ 对象转换为字符串：先调用`toString()`后调用`valueOf()`直到返回原始值。(调用过程中具有该方法或没有或具有时但该方法没返回原始值,就按顺序调用下一个方法,当都不返回原始值时,此时将报错)(可以自行通过修改原型方法验证)

+ 对象转换为数字：先调用`valueOf()`后调用`toString()`直到返回原始值。(过程同上)
  ```js
    Object.prototype.toString = function () {
    return 2;
  }
  Object.prototype.valueOf = function () {
    return 1;
  }
  ({x: 1}) + 1;// 2
  ```

所有对象都继承了两个转换方法：
`toString()`：返回一个反映这个对象的字符串。如下：
```js
({x:1,y:2}).toString();//[object Object]
[1,2,3].toString();//1,2,3
(function(x){}).toString();//function (x){}
/\d+/g.toString();///\d+/g
new Date(2010,0,1).toString();//Fri Jan 01 2010 00:00:00 GMT+0800 (中国标准时间)
```

另一个转换对象的函数是`valueOf()`：如果存在原始值，它就默认将对象转换为表示它的原始值。**对象为复合值，则返回对象本身**(实际上除日期对象外都返回本身)。
数组、函数和正则表达式继承了该默认方法(它们也是对象实际上)，调用后只会返回对象本身。*所以数组到数字的转换会先调用toString()转换为字符串后,在尝试能不能转换为数字。*
*日期类会返回它的内部表示：自1970年1月1日以来的毫秒数。（数字）*


### 操作符运算

#### 操作符
这里只列举比较少见的操作符：
+ `delete` 删除属性  运算结果为`Boolean`值
+ `typeof` 检查操作数类型 运算结果为字符串
+ `void`  返回`undefined` 运算结果为`undefined`
+ `instanceof` 测试对象类（是否为其实例） 结果为`Boolean`值
+ `in` 测试属性是否存在   测试结果为`Boolean`值

#### 操作数类型和结果类型
javasript运算符会根据需要对操作数进行类型转换

这里先介绍一个概念

##### 左值
表示表达式只能出现在赋值运算符的左侧，右值同理

#### 运算符

##### +运算符(不是一元运算符+)
加法操作的行为表现为：（先查看是否有对象，是对象则调用`toString()`转换为原始值，之后有字符串就都转换为字符串计算，否则数字计算）
1. 如果其中一个操作数是对象，则对象会遵循对象到原始值的转换：日期对象通过`toString()`方法执行转换，其他对象通过`valueOf()`方法转换（如果`valueOf()`返回原始值,实际上该方法大多数返回自身除非你修改了它）否则则用`toString()`
2. 在进行了对象到原始值的转换后，如果其中一个操作数是字符串，则另一个操作数也会转换为字符串，然后进行字符串拼接
3. 否则，两个操作数都转换为数字（或者`NaN`），然后进行加法

```js
true + true // 2:布尔值转换为数值
2 + null // 2:null转换为0后做加法
2 + undefined //NaN:undefined转换为NaN后做加法
```
当加法运算符和字符串和数字一起使用时，需要考虑*运算顺序*对结果的影响。

##### 一元运算符
+ 一元加法、减法（`+`、`-`）
  一元加法运算符把操*作数转换为数字*（或者`NaN`），返回这个转换后的数字，如果操作数本身是数字就返回这个数字本身。

+ 递增（`++`）递减（`--`）
  `++`对操作数进行增量（加一）操作，操作数是一个左值（变量、数组元素或对象属性）。运算符将操作数转换为数字，然后给数字加1，然后将加1后 的数值重新赋值给左值。

递增`++`的返回值依赖于它相对于操作数的位置，当运算符在操作数之前时，称为*前增量运算符*，它对操作数进行增量计算，并返回计算后的值。当运算符在操作数之后时，称为*后增量运算符*，它对操作数进行增量计算，但返回未做增量计算的值：
```js
var i = 1, j = ++i;//i和j都是2
var i = 1, j = i++;//i是2，j是1
```

##### 位运算符
该运算符将每个操作数为当作布尔值（`1 = true, 0 = false`）。位运算符要求操作数是整数，表示32位整型而不是64位浮点型。必要时，位运算符将操作数转换为数字，并将数字强制表示为32位整型，忽略小数部分和超过32位的二进制。位移运算符要求右操作数在0~31之间。在将其操作数转化为无符号32位整数后，它们将舍弃第五位之后的二进制位。
位运算符会将`NaN`、`Infinity`和`-Infinity`转换位`0`.

+ 按位与（`&`）（同为1为1）
  只有两个操作数相对应的位都是1时，结果中的这一位才是1。

+ 按位或（`|`）（有1则为1）
  如果其中一个操作数相应的位位1，或者两个操作数相应位都是1，那么结果中这一位位1.

+ 按位异或（`^`）（只有一个位1的位，这位为1）
  如果两个操作数只有一个位1，那么结果这位为1.

+ 按位非（`~`）
  一元运算符，相当于改变它的符号并减1.
  `~2;//-3`

+ 左移（`<<`）
  将第一个操作数的所有二进制进行左移操作，移动的位数右第二个操作数决定，移动位数位0~31之间的一个整数。新的位数由0补充。如：
  `7 << 2;//28`  7为111 左移两位为11100=28

+ 带符号右移（`>>`）
  同左移，右边溢出的位将忽略。移动后，如果第一个操作数是正数，则移位后0补填最高位，否则用1补填。
  `7 >> 1;//3`   7为111  移动后为 011=3

+ 无符号右移（`>>>`）

#### 相等、严格相等与不等运算符
**严格相等**运算符`===`首先计算操作数的值，然后比较这两个值，比较过程没有类型转换：
+	类型不同，不相等
+	都为`null`或都是`undefined`，则相等
+	两个值都是`true`或`false`，则相等
+	其中一个为`NaN`，不相等。只有当位`NaN`时，`x !== x`,为t`rue`
+	都为数值且值相等，相等。0与-0等
+	都为字符串且完全相同，提供了`String.localeCompare()`方法比较字符串
+	两个引用值指向同一个对象、数组和函数，相等。

**相等**运算符`==`，如果`===`相等，那么`==`一定相等：(都转换为数字进行对比)
+	操作数类型相同，则按===规则比较。

+	操作数类型不同，进行类型转换：
  + 一个值为`null`，另一个位`undefined`，则相等
  + 一个值为数字，一个为字符串，先将字符串转换为数字，然后进行比较。
  + 一个为`true`，则将其转换为1在比较。如果其中一个为`false`，则将其转换为0进行比较。
  + 一个为对象，另一个为数字或字符串，则对象通过`toString()`方法或`valueOf()`方法转换为原始值。Javascript内置类先尝试使用`valueOf()`，在尝试使用`toString()`，除了日期类，日期类先使用`toString()`转换，后使用`valueOf()`。
  + 其他不同类型之间的比较均不相等

#### 比较运算符
用来检测两个操作数的大小关系（数值大小或者字母表的顺序）:
+ 小于（`<`）
+ 大于（`>`）
+ 小于等于（`<=`）
+ 大于等于（`>=`）

只有**数字**和**字符串**才能正真执行比较操作，其他的要进行类型转换，规则：
+ 操作数为对象则转换为原始值：如果`valueOf()`返回一个原始值则使用否则用`toString()`
+ 转换原始值后如果都为字符串，则依照字母表顺序对两个字符串进行比较。（字母表顺序指组成这个字符串的16位Unicode字符的索引顺序）
+ 如果转换后至少有一个操作数不是字符串，那么两个操作数都转换为数字进行比较。当其中一个是`NaN`时总是返回`false`

`String.localCompare()`方法：参照本地语言的字母表定义的字符次序
对于*加法运算符*和*比较运算符*，前者更偏爱字符串，其中一个操作数为字符串时，则进行字符串拼接，而比较运算符更偏爱数字，只有当两个都为字符串时才进行字符串比较。

#### in运算符
`in`操作符希望左操作数是一个字符串或可以转换位字符串，右操作数是一个对象。如果右侧的对象拥有一个名为左操作数值的属性名，那么表达式返回`true`。
```js
var point={
  x:1,
  y:1
};
"toString" in point;//true  继承原型上方法
var data=[7,8,9];
"0" in data; //true有索引为0的元素
3 in data;//false 没有索引为3的元素
```

#### instanceof运算符
希望左操作数是一个对象，右操作数标识对象的类。如果左侧的对象是右侧类的实例，则返回`true`。由于javascript中对象的类是通过初始化它们的构造函数来定义的，所以`instanceof`的右操作数应当是一个函数。
```js
//原生实现一个instanceof方法
function instanceOf(obj, constructor) {
  if(typeof constructor !== 'function')return new Error('typeError');

  while (obj) {
    obj = obj.__proto__;
    if(obj.constructor == constructor){
      return true;
    }
  }
  return false;
}
```

#### typeof运算符
一元运算符，放在单个操作数的前面，操作数可以是任意类型，返回值为表示操作数类型的一个字符串，如下：
x	| typeof x
-|-
undefined	| Undefined
null | Object
true或false	| Boolean
任意数字或NaN	| Number
任意字符串 | String
任意函数 | Function
任意内置对象（非函数） | Object
任意宿主对象 | 由编译器各自实现的字符串

`typeof`可以直接像函数那样加`()`使用`typeof(x)`;
`typeof`特殊情况，对于可执行对象返回`function`比如内置对象和宿主对象（DOM和BOM）(这种情况就是低级IE中的，此时还需要检查nodeType属性来确定)

#### delete运算符
一元操作符用来删除对象属性或者数组元素。删除属性或者删除*数组*元素不仅仅是设置了一个`undefined`的值，
当为*对象*时，这个属性将不存在；
数组时，这个位置会设置为`undefined`且数组长度不变
```js
var o = {x: 1, y: 2};
delete o.x;  //o为{y:2}
var a = [1,2,3,4];
delete a[3];   //a为 [1, 2, 3, undefined × 1] length=4
```

`delete`希望它的操作数是一个左值，如果不是左值，那么将不进行任何操作同时返回`true`。
当为左值时，会删除这个指定的左值，删除成功返回`true`。（内置核心和客户端属性、用户通过`var`声明的变量、定义的函数和函数参数无法删除）
```js
var o={x: 1, y: 2};
delete o.x;//删除了x属性返回true
typeof o.x;//属性不存在返回undefined
delete o.x;//删除不存在属性，返回true
delete o;//删除var定义的变量，返回false

delete 1;//参数不是左值，返回true
this.x = 1;//没用var定义一个属性
delete x;//删除成功返回true
console.log(x);//运行错误没有x
```

#### void运算符
一元运算符，在操作数之前，操作数可以是任意类型。操作数会照常计算，但忽略计算结果并返回`undefined`。

#### 逻辑运算符
+ 逻辑与（`&&`）
  只有当两个操作数都为`true`时返回`true`，其中一个为`false`就返回`false`。
  当左侧操作数返回`false`，则直接返回左操作数值，并不会对右侧进行计算。如果左侧为真值，将计算右侧操作数值并作为整个表达式的计算结果：（假值为`false`、`null`、`undefined`、`0`、`-0`、`NaN`、`""`）
  ```js
  var a = {x: 1};
  var p = null;
  a && a.x;//1   都为真值，返回第二个操作数的值
  p && p.x;//null   第一个为假值，直接返回第一个操作数值

  // &&的行为成为短路，所以可以用代替某些if语句：
  if(a == b) stop();//只有当a=b时调用stop
  (a == b) && stop();//等价上述
  ```

+ 逻辑或（`||`）
  当其中一个是真值就返回一个真值。如果第一个操作数是真值，则返回第一个操作数并停止运算；否则，计算右侧表达式的值，并返回计算结果。
  该运算符最常用的方式是用来从一组备选表达式中选出第一个真值表达式，如：
  ```js
  var max=max_width||perferences.max_width||500;
  ```

  通常用在函数体内，用来给参数提供默认值：
```js
function stop(o, p) {
   p = p || {};
}
```

#### 运算符的副作用
`=`、`++`、`--`、`delete`运算符都会改变一个值，其他的不会

#### 运算符的优先级
属性访问表达式和调用表达式的优先级要比符号运算符和之前的运算符优先级都要高，如：
```js
typeof my.name[x];
//下面这个例子偏难，看理解没有
var a = {n: 1};
var b = a;
a.x = a = {n: 2};
a.x;//undefined
b.x;//{ n: 2}
```

当不确定优先级时，可以通过圆括号来强行指定运算次序。

#### 运算符的结合性
多个具有同级优先级的运算符按**从左到右**计算，而一元操作符、赋值和三元条件运算符都具有从右到左的结合性。如：
```js
q=a?b:c?d:e?f:g;//等价a?b:(c?d:(e?f:g));
```

#### 运算顺序
javasript总是严格按照从左到右的顺序来计算表达式 。
如`w = x + y * z`,首先计算子表达式`w`，再计算`x`、`y`、`z`的值，，然后`y`的值在和`z`相乘在加上`x`，最后赋值。
```js
var data = [1,2,3],i = 0;
data[i++] *= 2;  //  [2,2,3]     即data[0] = data[0] x 2
data[i++] = data[i++] * 2;//  [4,2,3] 先计算左边，此时i为0，在计算右侧，此时i为1

var a = 1;
b = (a++ ) + a;//该句中b=3
/* 在该运算符中，(1)计算b,(2)计算a++假设为c,(3)计算a,(4)计算c+a,(5)将c+a结果赋值给b
（在执行第三步时，a已变为2）*/
```

## 表达式

### 原始表达式
原始表达式是表达式的最小单位————不再包含其他表达式，原始表达式包含常量、直接量、关键字和变量。
```js
1.23//数字直接量
"hello" //字符串直接量
/pattern/g  //正则表达式直接量
```

保留字构成的原始表达式：
```js
true;
false;
null;
this;
```

变量构成的原始表达式：
```js
i;  //返回i的值
sum;
undefined;//全局变量，null为关键字
```

### 对象和数组的初始表达式
对象和数组初始化表达式实际上是一个新创建的对象和数组。
```js
//声明一个长度为7的数组
var newAr = [1,,,,,,5];
```
数组直接量中的列表逗号之间的元素可以省略，省略的空位会填充值`undefined`。

当数组以逗号结尾时，数组会忽略该逗号
```js
var newAr = [1,2,,3,];// [1,2,undefined,3]
```
对象的初始化表达式同数组类似

### 函数定义表达式
同变量声明一样的写法
```js
var square=function(x){ return x*x; } //一个函数表达式
```

### 属性访问表达式
属性访问有两种方式：
+ 通过需要访问的属性名称访问：这种方式不适合访问属性名为*保留字*、包含空格和标点符号，或数字（比如数组）
  ```js
  expression.identifier;
  ```
+ 通过另一个表达式来访问属性名称
  ```js
  expression[expression];
  ```
如：
```js
var o={x:1,y:{z:3}};
o.y.z; //3
o["y"].z;//3
```
其中的**表达式**会按从左到右依次计算。

### 调用表达式
一种调用函数或方法的语法表示。
```js
f(0);//f是一个函数表达式；0是一个参数表达式
```

当调用表达式求值时，首先计算函数表达式，然后计算参数表达式，得到一组参数值。如果函数使用`return`语句给出一个返回值，那么这个值就是这个表达式调用的值，否则表达式的值就为`undefined`。

### 对象创建表达式(实例化)
创建一个对象并调用一个函数（这个函数称为构造函数）初始化新对象的属性。
如果对象创建表达式不需要传入任何参数给构造函数，那么空圆括号可以省略。
```js
new Object;//等价于 new Object()
```

**过程**：当计算一个对象创建表达式的值时，首先创建一个新的空对象，然后通过传入指定的参数并将这个新对象当作`this`的值来调用一个指定的函数。被当作构造函数的函数不会返回一个值，并且新创建并被初始化后的对象就是整个对象创建表达式的值;如果一个构造函数返回一个对象值，则这个对象值就会作为对象创建表达式的值。

### 关系表达式
关系表达式总是返回一个布尔值,如`a == b`

### 表达式计算
`eval()`函数可以解释运行由javasript源码组成的字符串，并产生一个值.
如果一个函数调用了`eval()`，那么解释器将无法进一步优化，且`eval()`可以被赋予其他名字：
```js
var f=eval;  //eval()
```

#### eval()
接受一个参数，如果参数是字符串则当作javasript代码进行编译，编译失败则抛出错误，编译成功时返回最后一个表达式或语句的值，没有值则返回`undefined`。
如果参数不是字符串，则返回这个参数。

`eval()`函数会使用调用它所在的变量作用域环境，即一个函数定义了一个局部变量`x`，然后调用`eval('x')`，则这个`x`来源于局部变量`x`。
`eval()`的字符串执行时的上下文环境和调用函数的上下文环境是一样的，如：
```js
var foo = function (a) {
  eval(a);
};
foo("return ;"); //异常 这里相当于不存在函数内
```

直接调用`eval()`时，它总会在调用它的上下文作用域内执行。其他间接调用则使用全局对象作为其上下文作用域，并且无法读、写、定义局部变量和函数。
```js
var geval = eval;//改名以备间接调用
var  x = "global", y = "global";
function f() {
  var x = "local";
  eval("x += 'changed'; ");
  return x; //返回局部变量 localchanged
}
function g() {
  var y = "local";
  geval("y += 'changed';");//改变全局变量为globalchanged
  return y;//返回局部变量local
}
```

（IE9之前的版本，通过别名调用`eval()`时并不是全局`eval()`，而是局部，但IE定义了一个`execScript()`来完成全局`eval()`功能，但该函数总是返回`null`）

#### 严格模式下的eval()
当严格模式下调用，代码以`use strict`开始，`eval()`执行的代码段可以查询或更改局部变量，但不能在局部作用域中定义新的函数或变量；`eval`成为保留字，且不能用别名。
```js
'use strict';
(function () {
  eval('var a = 1;');
  return a;// 异常，a未定义
})()
```

### 表达式语句
赋值语句、递增运算符和递减运算符和赋值语句有关、delete运算符、函数调用都是表达式语句

#### 复合语句和空语句
用花括号将多条语句括起来可以形成一条复合语句。
```js
{
  var x = 5;
  console.log(x);
}
```
但要注意，语句块结尾不需要分号。

下为空语句:
```js
    ;
//当创建一个空循环体时非常有用，比如:
var a = [];
for(i = 0; i < a.length; a[i++] = 0) ;//最好在空语句时添加注释
```

#### 声明语句
`var`和`function`都是声明语句，它们声明或定义变量或函数。(ES6新增`let` `const`)

##### var
用来声明一个或多个变量，每个变量用，隔开。`var`声明的变量无法通过`delete`删除。当用`var`未声明初始化表达式时，变量值为`undefined`。

##### function
函数声明语句：
```js
function name(arg) {
  statements
}
```

函数定义表达式：
```js
var name=function(arg){
  statements
};
```
函数表达式会将函数定义与初始化显式的提升到脚本或函数的顶部，但值需在定义处赋予;而函数声明语句会将函数定义初始化赋值都提升到整个作用域，意思是可以在声明前调用。

使用`var`的话，只有变量定义和初始化提前了————变量的赋值没有，但使用函数声明，函数名与函数体都会提前。

#### 条件语句、循环语句

##### switch语句
`break`和`return`都会终止`switch`语句，`switch`语句的条件使用的是`===`操作，不会进行类型转换。

##### while、do/while、for、for/in
只要条件结果为真值时，就会继续循环，例如遍历链表数据结构：
```js
for(;o.next;o.next) /*empty*/;
return o;//返回最后一个对象
```

`for`循环中三个条件都可以忽略，但是两个分号必须有。

`for/in`语句语法如：
`for(variable in object){ statement }`
`variable`通常是一个变量名，也可以是一个可以产生左值的表达式或则一个通过`var`语句声明的变量，总之必须是一个适合用于赋值表达式左侧的值。

#### continue语句
`continue`的行为在不同的循环体中有所不同：
+ 在`while`循环中，在循环开始时会检查条件，为`true`时才会从头开始执行
+ 在`do/while`循环中，程序会跳到结尾，重新检查循环条件，之后才会继续下一次循环
+ 在`for`循环中，先检测自增表达式，然后再次测试条件，在判断是否循环。
+ 在`for/in`循环中，直接循环下一次

#### 标签语句
语句是可以添加标签的，标签是由语句前的标识符和冒号组成：
`identifier：statement`

通过给语句定义标签，可以在程序任何地方通过标签名引用这条语句。
`break`、`continue`是唯一可以使用语句标签的语句。（可以用来跳出多重嵌套循环的外部循环）

#### finally语句
只要`try`语句中的代码执行了，`finally`语句就会执行。当由于`return`、`continue`、`break`语句使得解释器跳出``try``语句块时，解释器在执行新目标代码前优先执行`finally`块中的语句。如果不存在处理异常的局部`catch`从句，解释器会首先执行`finally`语句中的逻辑，然后向上传播这个异常，知道找到能处理这个异常的`catch`从句。
如果`finally`语句通过`return`、`continue`、`break`、`throw`等语句或发生了异常而改变了程序执行流程，解释器都将忽略`try`中的改变。
```js
var foo = function(){
  try{
  throw new Error("1");
  }finally{
  return 1;//改写为 throw new Error("2")时
  }
}
console.log(foo());//返回1    抛出2错误，没有1错误
```

#### with语句
```js
with(object){
  statement
}
//以上表示object.statement
```
这个语句将`object`添加到作用域链的头部，然后执行`statement`，最后把作用域链恢复到原始状态。
严格模式中禁止使用`with`语句，使用`with`语句的代码难于优化，并且运行慢。
```js
with(o){
  x=1;
}
```
如果对象`o`有一个`x`属性，则给这个属性赋值为1，如果没有x属性，则这个代码和不使用`with`语句一样，给全局变变量或局部变量`x`赋值。`with`语句只能读取，不能创建属性。

#### debugger语句
这个语句用来产生一个断点，javascript代码的执行会停止在断点的位置

#### use strict
使用严格模式，只能出现在代码开始或函数体开始，并与普通模式有以下几点不同：
+ 禁止使用`with`语句
+ 所有变量要先声明
+ 在严格模式下全局调用函数中的`this`为`undefined`。
+ 通过`call`或`apply`调用函数时，this是通过call或apply传入的第一个参数。
+ 在严格模式，给只读属性和不可扩展的对象创建新成员会抛出类型错误。
+ 在严格模式，传入`eval()`的代码不能在调用程序所在的上下文中声明变量或定义函数。
+ 严格模式中，函数的`arguments`对象拥有传入函数值的静态副本。非严格模式中，`arguments`里的数组元素和函数参数都是指向同一个值的引用。
+ 严格模式中，`delete`运算符后跟随非法的标识符（变量、函数、函数参数）会抛出语法错误。
+ 严格模式中，试图删除一个不可配置的属性将抛出一个类型错误。
+ 严格模式中，在一个对象直接量中定义两个或多个同名属性将产生一个语法错误。
+ 严格模式中，函数声明中存在两个或多个同名参数将产生语法错误。
+ 严格模式中不允许使用八进制整数直接量（以0为前缀，而不是0x为前缀）
+ 严格模式中，`eval`、`arguments`当做关键字，它们的值是不能更改的。
+ 严格模式限制了调用栈的检查能力。`arguments`、`caller`和`arguments.callee`都会抛出一个类型错误异常。