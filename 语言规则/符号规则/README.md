# 符号规则

这一部分主要涉及`Javascript`中的符号与具体的运行规则。

## 分号的作用

如果当前语句和随后的*非空格字符*不能当成一个整体来解析时，`Javascript`会在当前语句行结束处填补分号。如：

```js
var y = x + f(a + b).toString()
//javascript解析为var y=x+f(a + b).toString(),相当于f被解析为函数
```

但在某些情况下会不一样：

-   `return` `break` `continue` : 它们会直接在后面添加分号

```js
function test(a) {
    return
    a
}
test(1) //undefined
```

-   `++` `--` : 它们会自动应用于下一句语句

如：

```js
//以下语句解析为 x; ++y 本意为 x++; y
x
++y
```

通常来讲，如果一条语句以`( [ / + -`开始，那么它极有可能和前一条语句一起解析。（解决方法可以在这些符号前显示添加`;`号）

## 运算规则

这里主要讲述各种值之间的值类型转换与运算符的运行规则

### 类型转换

此处列举几个**特殊**的类型转换：
`null`、`""`（空字符串）、`[]`（任意空数组）转换为数字时为`0`。

`[9]`含有一个数字元素的数组会转换为数字时会转换为其中的数字元素值（_先转换为字符串然后转换为数字_）

**当原始值转换为对象时调用它们对应的构造函数**。(`null`、`undefined`会导致错误, 但这里有个特殊情况当`Ojbect(null/undefined`)时会返回一个空对象)

#### 显示类型转换

当不通过`new`调用`Boolean()`、`Number()`、`String()`构造函数时，他们会作为类型转换函数，并其构造函数字面含义将传入的值转化为对应类型，特殊情况下按照上面的规则转换；这里调用`Object()`则会根据传入值，内部再调用对应值类型的构造函数。

除了`null`、`undefined`外的任何值都具有`toString()`方法(与`String()`方法相似，但规则不同；调用`new Object(null/undefined)`会生成一个空对象，这是特殊情况)

#### 隐式类型转换

如`+`运算符的一个操作数是字符串，它将会把另一个操作数也转换为字符串。

一元`+`运算符会将其操作数转换为数字；一元`!`操作符会将操作数转换为布尔值取反。

```js
x + '' //等价String(x)
;+x //等价与Number(x)
!!x //等级于Boolean(x)
```

`1 + b`和`1 == b`应用到对象到原始值的转换包含*日期对象*的这一种特殊情形。_对于非日期对象，对象到原始值的转换基本上是对象到数字的转换(即调用`valueOf()`)，而日期对象则使用对象到字符串的转换模式(即调用`toString()`)_。

`<`运算符及其他运算符(除去日期对象)：任何对象首先尝试`valueOf()`，然后调用`toString()`，**不管得到的原始值是否能直接使用，它都不会进一步被转换为数字或字符串**。(这样调用的原因是因为只有数字才能做比较)

`+`、`==`、`!=`是唯一执行将到上述特殊字符串转换为原始值的运算符。

其他运算符到特定类型的转换都很明确：`-`运算符把两个操作数都转换为数字。

```js
let dataObj = new Date()
dataObj + 1 // string
dataObj - 1 // number
dataObj == dataObj.toString() // 隐式和显式的字符串转换
dataObj > dataObj - 1 // >将日期转化为数字
```

#### 其他转换方式

`Javascript`提供了专门的函数和方法来做更加精准的*数字到字符串*和*字符串到数字*的转换：

`Number`类定义了一些方法：

-   `toString()`方法接收表示转换基数的可选参数（2~36 之间），如果不指定参数则按十进制进行转换。
-   `toFixed(位数)`根据小数点后的指定位数将数字转化为字符串(四舍五入，五入的情况必须大于 5，即等于 5 也为舍去)。
-   `toExponential(位数)`使用指数记数法将数字转换为指数形式的字符串。
-   `toPrecision(位数)`根据指定的有效数字位数将数字转换为字符串。

_三种方法都会适当的进行四舍五入_

```js
let c = 123456.789
c.toFixed(5) //123456.78900  保留5位小数的字符串
c.toExponential(3) //1.235e+5  保留3位小数的字符串
c.toPrecision(10) //123456.7890 共10位数字的字符串
```

如果向`Number()`转换函数传入一个字符串，它会尽量转换为一个整数或浮点数直接量(基于`10`进制)(唯有纯数字字符串或者带一个`.`才能转换为数字)

##### 利用全局函数将字符串转换为数字

`parseInt(string, [进制])`：只解析为整数(解析字符串)，可选择传入第二个参数表示解析的字符串是什么进制(`2~36`)(为`0`时为十进制，其他的时候返回`NaN`)如果字符串的前缀是`0x`或`0X`，则`parseInt()`会将其解释为`16`进制数。解析的结果为`10`进制数字。

`parseFloat()`：只解析为整数与浮点数（解析字符串），可接收第二个参数表示转换的进制。

这里强调下，是将字符串直接解读为对应的进制的字符串，然后在转化为数字，比如：

```js
parseInt('10', 2)
```

这里即`10`(二进制)，最后转化为`10`进制的数字`2`

#### 具体的转换过程

下面将介绍对象转换为各种原始值具体的过程，调用了什么方法。

##### 对象转换为原始值

-   对象转换为布尔值：所有对象都转换为`true`,即使是`new Boolean(false)`也转换为`true`(因为其生成的仍是一个对象)

-   对象转换为字符串：先调用`toString()`后调用`valueOf()`直到其中一个返回原始值。(调用过程中具有该方法或没有或具有时但该方法没返回原始值，就按顺序调用下一个方法，当都不返回原始值时，此时将报错。可以自行通过修改原型方法验证)

-   对象转换为数字：先调用`valueOf()`后调用`toString()`直到返回原始值。(过程同上)

    ```js
    Object.prototype.toString = function () {
        return 2
    }
    Object.prototype.valueOf = function () {
        return 1
    }
    ;({ x: 1 } + 1) // 2
    ```

所有对象都继承了两个转换方法：
`toString()`：返回一个反映这个对象的字符串。如下：

```js
;({ x: 1, y: 2 }.toString()) //[object Object]
;[1, 2, 3].toString() //1,2,3
;(function (x) {}.toString()) //function (x) {}
;/\d+/g.toString() ///\d+/g
new Date(2010, 0, 1).toString() //Fri Jan 01 2010 00:00:00 GMT+0800 (中国标准时间)
```

另一个转换的方法是`valueOf()`：如果存在原始值，它就默认将对象转换为表示它的原始值。**对象为引用类型，则返回对象本身**(实际上除日期对象外都返回本身)。

数组、函数和正则表达式继承了该默认方法(它们实际上也是对象)，调用后只会返回对象本身；_日期类会返回它的内部表示：自 1970 年 1 月 1 日以来的毫秒数。（数字）_

### 操作符运算

#### 操作符

这里只列举比较常见的操作符：

-   `delete` 删除属性，运算结果为`Boolean`值
-   `typeof` 检查操作数类型，运算结果为字符串
-   `void` 返回`undefined`，运算结果为`undefined`
-   `instanceof` 测试对象类（是否为某个构造函数的其实例），结果为`Boolean`值
-   `in` 测试某个名称键名是否存在某个对象中，测试结果为`Boolean`值

#### 操作数类型和结果类型

Javascript 运算符会根据需要对操作数进行类型转换

这里先介绍一个概念

左值`LHS`：表示表达式只能出现在赋值运算符的左侧，右值同理

#### 运算符

##### +运算符(不是一元运算符+)

加法操作的行为表现为：（先查看是否有对象，是对象则调用`toString()`转换为原始值，之后有字符串就都转换为字符串计算，否则数字计算）, 具体过程为：

1. 如果其中一个操作数是对象，则对象会遵循对象到原始值的转换：日期对象通过`toString()`方法执行转换，其他对象通过`valueOf()`方法转换（如果`valueOf()`返回原始值,实际上该方法大多数返回自身除非你修改了它）否则则用`toString()`
2. 在进行了对象到原始值的转换后，如果其中一个操作数是字符串，则另一个操作数也会转换为字符串，然后进行字符串拼接
3. 否则，两个操作数都转换为数字（或者`NaN`），然后进行加法

```js
let a = {
    toString() {
        return '文本'
    },

    valueOf() {
        return 182
    }
}
1 + a // 183
'' + a // '182'

true + true // 2:布尔值转换为数值
2 + null // 2:null转换为0后做加法
2 + undefined //NaN:undefined转换为NaN后做加法
```

当加法运算符和字符串和数字一起使用时，需要考虑*运算顺序*对结果的影响。

##### 一元运算符

-   一元加法、减法（`+`、`-`）
    一元加法运算符把操*作数转换为数字*（或者`NaN`），返回这个转换后的数字，如果操作数本身是数字就返回这个数字本身。

-   递增（`++`）递减（`--`）
    `++`对操作数进行增量（加一）操作，操作数是一个左值（变量、数组元素或对象属性）。运算符将操作数转换为数字，然后给数字加 1，然后将加 1 后 的数值重新赋值给左值。

递增`++`的返回值依赖于它相对于操作数的位置，当运算符在操作数之前时，称为*前增量运算符*，它对操作数进行增量计算，并返回计算后的值。当运算符在操作数之后时，称为*后增量运算符*，它对操作数进行增量计算，但返回未做增量计算的值：

```js
var i = 1, j = ++i;//i和j都是2
------------------------------
var i = 1, j = i++;//i是2，j是1
```

##### 位运算符

该运算符将每个操作数为当作布尔值（`1 = true, 0 = false`）。位运算符要求操作数是整数，表示 32 位整型而不是 64 位浮点型。必要时，位运算符将操作数转换为数字，并将数字强制表示为 32 位整型，忽略小数部分和超过 32 位的二进制。位移运算符要求右操作数在`0~31`之间。在将其操作数转化为无符号 32 位整数后，它们将舍弃第五位之后的二进制位。
位运算符会将`NaN`、`Infinity`和`-Infinity`转换位`0`.

-   按位与（`&`）（同为 1 为 1）
    只有两个操作数相对应的位都是 1 时，结果中的这一位才是 1。

-   按位或（`|`）（有 1 则为 1）
    如果其中一个操作数相应的位位 1，或者两个操作数相应位都是 1，那么结果中这一位位 1。

-   按位异或（`^`）（不同为 1，相同为 0）
    如果两个对应的二进制位相同则该位为 0，不同则为 1。

-   按位非（`~`）
    一元运算符，相当于改变它的符号并减 1.

    ```js
    ~2 // -3
    ```

-   左移（`<<`）
    将第一个操作数的所有二进制进行左移操作，移动的位数右第二个操作数决定，移动位数位 0~31 之间的一个整数。新的位数由 0 补充。如：

    ```js
    7 << 2 // 28 —— 7为111 左移两位为11100=28
    ```

-   带符号右移（`>>`）
    同左移，右边溢出的位将忽略。移动后，如果第一个操作数是正数，则移位后 0 补填最高位，否则用 1 补填。

    ```js
    7 >> 1 // 3 —— 7为111  移动后为 011=3
    ```

-   无符号右移（`>>>`）(不论正负,高位均补 0)

#### 相等、严格相等与不等运算符

##### 严格相等

严格相等运算符`===`首先计算操作数的值，然后比较这两个值，比较过程没有类型转换：

-   类型不同，不相等
-   都为`null`或都是`undefined`，则相等
-   两个值都是`true`或`false`，则相等
-   其中一个为`NaN`，不相等。只有当位`NaN`时，`x !== x`,为 t`rue`
-   都为数值且值相等，相等。`0`与`-0`等
-   都为字符串且完全相同，提供了`String.localeCompare()`方法比较字符串
-   两个引用值指向同一个对象、数组和函数，相等。

##### 相等

相等运算符`==`，如果`===`相等，那么`==`一定相等：(都转换为数字进行对比)

-   操作数类型相同，则按`===`规则比较。

-   操作数类型不同，进行类型转换：
    -   一个值为`null`，另一个位`undefined`，则相等
    -   一个值为数字，一个为字符串，先将字符串转换为数字，然后进行比较。
    -   一个为`true`，则将其转换为 1 在比较。如果其中一个为`false`，则将其转换为 0 进行比较。
    -   一个为对象，另一个为数字或字符串，则对象通过`toString()`方法或`valueOf()`方法转换为原始值。Javascript 对象先尝试使用`valueOf()`，再尝试使用`toString()`，除了日期类先使用`toString()`转换，后使用`valueOf()`。
    -   其他不同类型之间的比较均不相等

#### 比较运算符

用来检测两个操作数的大小关系（数值大小或者字母表的顺序）:

-   小于（`<`）
-   大于（`>`）
-   小于等于（`<=`）
-   大于等于（`>=`）

只有**数字**和**字符串**才能正真执行比较操作，其他的要进行类型转换，规则：

-   操作数为对象则转换为原始值：如果`valueOf()`返回一个原始值则使用否则用`toString()`
-   转换原始值后如果都为字符串，则依照字母表顺序对两个字符串进行比较。（字母表顺序指组成这个字符串的 16 位`Unicode`字符的索引顺序）
-   如果转换后至少有一个操作数不是字符串，那么两个操作数都转换为数字进行比较。当其中一个是`NaN`时总是返回`false`

`String.localCompare()`方法：参照本地语言的字母表定义的字符次序
对于*加法运算符*和*比较运算符*，前者更偏爱字符串，其中一个操作数为字符串时，则进行字符串拼接，而比较运算符更偏爱数字，只有当两个都为字符串时才进行字符串比较。

#### 总结

1. 在操作运算中(如`+`)，其中一个操作数为字符串则进行字符串运算，都不为时进行数字运算

2. 在比较运算中(`>/<`), 都转换为数字进行运算, 除非两个操作数都是字符串

3. 在操作运算中, 对象转换为原始值先调用`valueOf()`后调用`toString()`, 日期对象相反

#### in 运算符

`in`操作符希望左操作数是一个字符串或可以转换位字符串，右操作数是一个对象。如果右侧的对象拥有一个名为左操作数值的属性名，那么表达式返回`true`。

```js
var point = {
    x: 1,
    y: 1
}
'toString' in point //true  继承原型上方法
var data = [7, 8, 9]
'0' in data //true有索引为0的元素
3 in data //false 没有索引为3的元素
```

#### instanceof 运算符

希望左操作数是一个对象，右操作数标识对象的类。如果左侧的对象是右侧类的实例，则返回`true`。由于 Javascript 中对象的类是通过初始化它们的构造函数来定义的，所以`instanceof`的右操作数应当是一个函数。

```js
//原生实现一个instanceof方法
function instanceOf(obj, constructor) {
    if (typeof constructor !== 'function') return new Error('typeError')

    while (obj) {
        superObj = Object.getPrototypeOf(obj)

        if (superObj.constructor == constructor) {
            return true
        }
    }
    return false
}
```

#### typeof 运算符

一元运算符，放在单个操作数的前面，操作数可以是任意类型，返回值为表示操作数类型的一个字符串，如下：
x|typeof x
:-|:-
`undefined`|`undefined`
`null`|`object`
`true`或`false`|`boolean`
`Symbol(...)`|`symbol`
`1n`|`bigint`
任意数字或`NaN`|`number`
任意字符串|`string`
任意函数|`function`
任意内置对象(非函数)| `object`
任意宿主对象|由编译器各自实现的字符串

`typeof`可以直接像函数那样加`()`使用`typeof(x)`;
`typeof`特殊情况，对于可执行对象返回`function`比如内置对象和宿主对象（DOM 和 BOM）(这种情况就是低级 IE 中的，此时还需要检查`nodeType`属性来确定)

#### delete 运算符

一元操作符用来删除对象属性或者数组元素。删除属性或者删除*数组*元素情况不同，
当为*对象*时，这个属性将不存在；
数组时，这个位置会设置为`undefined`且数组长度不变。

```js
var o = { x: 1, y: 2 }
delete o.x //o为{y:2}
var a = [1, 2, 3, 4]
delete a[3] //a为 [1, 2, 3, undefined × 1] length=4
```

`delete`希望它的操作数是一个左值，如果不是左值，那么将不进行任何操作同时返回`true`。

当为左值时，会删除这个指定的左值，删除成功返回`true`。（内置核心和客户端属性、用户通过`var`声明的变量、定义的函数和函数参数无法删除）

```js
var o = {x: 1, y: 2};
delete o.x;//删除了x属性返回true
typeof o.x;//属性不存在返回undefined
delete o.x;//删除不存在属性，返回true
delete o;//删除var定义的变量，返回false

delete 1;//参数不是左值，返回true
this.x = 1;//没用var定义一个属性
delete x;//删除成功返回true
console.log(x);//运行错误没有x
```

#### void 运算符

一元运算符，在操作数之前，操作数可以是任意类型。操作数会照常计算，但忽略计算结果并返回`undefined`。

#### 逻辑运算符

-   逻辑与（`&&`）
    只有当两个操作数都为`true`时返回`true`，其中一个为`false`就返回`false`。
    当左侧操作数返回`false`，则直接返回左操作数值，并不会对右侧进行计算。如果左侧为真值，将计算右侧操作数值并作为整个表达式的计算结果：（假值为`false`、`null`、`undefined`、`0`、`-0`、`NaN`、`""`）

    ```js
    var a = { x: 1 }
    var p = null
    a && a.x //1   都为真值，返回第二个操作数的值
    p && p.x //null   第一个为假值，直接返回第一个操作数值

    // &&的行为成为短路，所以可以用代替某些if语句：
    if (a == b) stop() //只有当a=b时调用stop
    a == b && stop() //等价上述
    ```

-   逻辑或（`||`）
    当其中一个是真值就返回一个真值。如果第一个操作数是真值，则返回第一个操作数并停止运算；否则，计算右侧表达式的值，并返回计算结果。
    该运算符最常用的方式是用来从一组备选表达式中选出第一个真值表达式，如：

    ```js
    var max = max_width || perferences.max_width || 500
    ```

    通常用在函数体内，用来给参数提供默认值：

```js
function stop(o, p) {
    p = p || {}
}
```

#### 运算符的副作用

`=`、`++`、`--`、`delete`运算符都会改变一个值，其他的不会

#### 运算符的优先级

属性访问表达式和调用表达式的优先级要比符号运算符和之前的运算符优先级都要高，如：

```js
//下面这个例子偏难，看理解没有
var a = { n: 1 }
var b = a
a.x = a = { n: 2 }
a.x //undefined
b.x //{ n: 2}
```

当不确定优先级时，可以通过圆括号来强行指定运算次序。

#### 运算符的结合性

多个具有同级优先级的运算符按**从左到右**计算，而一元操作符、赋值和三元条件运算符都具有从右到左的结合性。如：

```js
q = a ? b : c ? d : e ? f : g
//等价a ? b : (c ? d : (e ? f : g));
```

#### 运算顺序

Javascript 总是严格按照从左到右的顺序来计算表达式 。
如`w = x + y * z`,首先计算子表达式`w`，再计算`x`、`y`、`z`的值，，然后`y`的值在和`z`相乘在加上`x`，最后赋值。

[参考运算符优先级表](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

下面是一个具体运算的例子：

```js
var data = [1, 2, 3],
    i = 0;

data[i++] *= 2;  //  [2,2,3]     即data[0] = data[0] x 2
----------上下两例子独立------------------------
data[i++] = data[i++] * 2;//  [4,2,3] 先计算左边，此时i为0，在计算右侧，此时i为1

var a = 1;
b = (a++) + a;//该句中b=3
/* 在该运算符中，(1)计算b,(2)计算a++假设为c,(3)计算a,(4)计算c+a,(5)将c+a结果赋值给b
（在执行第三步时，a已变为2）*/
```
