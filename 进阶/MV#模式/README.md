# MV*模式

这里我们主要是学习三个常见但重要的架构模式：`MVC`(模型-视图-控制器)和MVP(模型-视图-表示器)和`MVVM`(模型-视图-视图模型)，那么首先来了解一下关于它们的基础知识。

## MVC

`MVC`是一种架构设计模式，它通过关注点分离鼓励改进应用程序组织。它强调将业务数据(`Model`)与用户界面(`View`)隔离，第三个组件(`Controller`)管理逻辑和用户输入。

最初一个被称为分离表示的概念被用作在领域对象和表示对象之间做清晰划分的方法，领域对象在现实世界中塑造概念(如一张图片、一个人)，表示对象将具体画面呈现给用户。之后，`Smalltalk`进一步延伸了这一概念，在其中新增了一个从用户界面分离出应用程序逻辑的目的组件，它的目的在于解耦应用程序的这些部分，并同时将其应用程序的其他接口实现`Model`(模块)复用。在这个阶段，`MVC`的主要构成为以下部分：

- `Model`代表特定于领域的数据，不了解用户界面(`View`(视图)和`Controller`(控制器))。当一个`Model`(模型)改变时，它会通知它的观察者。
- **`View`描绘的是`Model`的当前状态**，即当前展示给用户的视图。`Observer`模式用于让`View`了解`Model`什么时候更新或修改。
- `Presentation`由`View`关注，但不只是单个`View`(视图)和`Controller`(控制器)，**屏幕上显示的每个部分或者元素都需要`View-Controller`对**。
- **`Controller`在这个`View-Controller`对中的作用是处理用户交互**，为`View`做决定。

在该模式中，`View`观察到`Model`，当`Model`发生变化时，`View`立即做出反应。这里我们可以清楚的看出其用到了`Observer`模式，在此，**为了让应用程序变得有用，在`Model`中对数据的任何更改都应该使`View`立即刷新**。

### Model(模型)

`Model`管理应用程序的数据。`Model`不涉及用户界面，也不涉及表示层，而是代表应用程序可能需要的独特形式的数据。**当`Model`(模型)改变时(如它更新时)，它通常会通知它的观察者(如`View`(视图))**

这里我们举一个具体的例子：假设有一张图片，则它的`Model`可能为如下：

```js
let photo = {
    defaults: {
        src: './home/placeholder.jpg',
        title: 'A photo',
        viewed: false
    }
}
```

**一个`Model`(模型)可能存在多个观察它的`View`(视图)**。比如上述的图片包含3个元数据，图片的`URL`、标题和是否显示，对于前两个部分，完全可以单独提供两个`View`(视图)来对其进行显示。

这里一个`Model`就涉及(或拥有)一个管理应用程序状态`state`(即里面的数据)，它们主要和业务数据有关。

### View(视图)

**视图则是`Model`(模型)的可视化表示**，表示当前`Model`的`state`(状态)下的视图。

**在`Javascript`中`View`是关于构建和维护一个`DOM`元素**，一个View(视图)通常检测一个Model(模型)，并在Model(模型)更改时通知，时View(视图)本身能够相应的更新。

用户可以与View(视图)交互，包括读取和编辑Model(模型)，即在Model(模型)中获取或设置相应的属性。但是，当用户编辑Model时，更新Model的实际任务其实是在Controller(控制器)上完成的。

#### 模版

在支持`MVC/MV*`的`Javascript`框架上下文中，都会涉及一个`Javascript`模版。这里有两个经典的模版解决方案(`Handlebars.js`和`Mustache`)，它们通常是用于将`View`模版定义为包含模版变量的标记，并可以使用特殊的变量语法来对变量进行定界(例如`{{name}}`就表示一个变量`name`)。同样，框架可以接收`JSON`形式的数据(`Model`模型实例可以被转换为这种形式，这样我们就可以独立的专注于编写`Model`与模版，它们之间的数据绑定工作就交给框架来完成。

但是注意模版本身并不是`View`(视图)，`View`是一个用于检测`Model`并保持可视化表示更新的对象。模版可能是一种指定部分或甚至所有`View`对象的**声明方式**。

### Controller(控制器)

`Controller`(控制器)是`Model`(模型)和`View`(视图)之间的中介，当用户操作`View`(视图)时，它通常负责更新`Model`(模型)。

例如，在一个图片库应用中，`Controller`(控制器)将负责处理用户对特定图片`View`(视图)的编辑更改，当用户完成编辑后，更新一个特定的图片`Model`(模型)。

### MVC为我们提供了什么

`MVC`中的这种关注点分离有利于进一步简化应用程序功能的模块化，并能够实现：

- **整体维护更容易。**
- **解耦`Model`(模型)和`View`(视图)**，这意味着它能够更直接地编写业务逻辑的单元测试。
- 在整个应用程序中，底层`Model`(模型)和`Controller`(控制器)**代码的重复被消除**了。

## MVP

模型-视图-表示器(`MVP`)是`MVC`设计模式的一种衍生模式，专注于改进表示逻辑。

### Model、View和Presenter

`MVP`中的`P`代表表示器。这是一个包含用于`View`(视图)的用户界面业务逻辑的组件。与`MVC`不同，来自`View`的调用将委托给表示器，表示器是从`View`中解耦，通过接口与它对话。

在`MVP`中，当`Model`(模型)变化时，监控`Model`和更新`View`。`P`将`Model`有效地绑定至`View`，这是以前在`MVC`中`Controller`的责任。

由`View`进行请求，表示器执行任何与用户请求有关的工作，并将数据回传给它们。在这方面，它们检索数据并操作数据，并确定应如何在`View`中显示这些数据。`Model`可能会触发事件，表示器的角色是订阅它们，这样就可以更新`View`。在这种被动架构中，没有直接数据绑定的概念。`View`暴露了`setter`设置器，表示器可以用它来设置数据。
